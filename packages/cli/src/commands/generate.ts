// =============================================================================
// GENERATE COMMAND — Generate database schema files from Summa table defs
// =============================================================================

import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import * as p from "@clack/prompts";
import type { ColumnDefinition, TableDefinition } from "@summa/core";
import { Command } from "commander";
import pc from "picocolors";
import { getConfig } from "../utils/get-config.js";

// =============================================================================
// TABLE NAME HELPERS
// =============================================================================

/** Convert camelCase table name to snake_case for SQL. */
function toSnakeCase(str: string): string {
	return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

/** Capitalize the first letter of a string. */
function capitalize(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

// =============================================================================
// DRIZZLE GENERATOR
// =============================================================================

const DRIZZLE_TYPE_MAP: Record<string, string> = {
	uuid: 'uuid("$COL")',
	text: 'text("$COL")',
	bigint: 'bigint("$COL", { mode: "number" })',
	integer: 'integer("$COL")',
	boolean: 'boolean("$COL")',
	timestamp: 'timestamp("$COL", { withTimezone: true })',
	jsonb: 'jsonb("$COL")',
	serial: 'serial("$COL")',
	tsvector:
		'customType<{ data: string; driverData: string }>({ dataType: () => "TSVECTOR" })("$COL")',
};

function generateDrizzleColumn(colName: string, col: ColumnDefinition): string {
	const template = DRIZZLE_TYPE_MAP[col.type];
	if (!template) return `// unknown type: ${col.type} for ${colName}`;

	let line = `\t\t${colName}: ${template.replace("$COL", colName)}`;
	if (col.primaryKey) line += ".primaryKey()";
	if (col.notNull) line += ".notNull()";
	if (col.default === "NOW()") line += ".defaultNow()";
	else if (col.default) line += `.default(${col.default})`;
	if (col.references) {
		line += `.references(() => ${col.references.table}.${col.references.column})`;
	}

	return `${line},`;
}

function generateDrizzleTable(name: string, def: TableDefinition, schema: string): string {
	const tableName = toSnakeCase(name);
	const lines: string[] = [];

	if (schema !== "public") {
		lines.push(`export const ${name} = summaSchema.table(`);
	} else {
		lines.push(`export const ${name} = pgTable(`);
	}
	lines.push(`\t"${tableName}",`);
	lines.push("\t{");

	for (const [colName, col] of Object.entries(def.columns)) {
		lines.push(generateDrizzleColumn(colName, col));
	}

	lines.push("\t},");

	// Indexes
	if (def.indexes && def.indexes.length > 0) {
		lines.push("\t(table) => [");
		for (const idx of def.indexes) {
			const cols = idx.columns.map((c) => `table.${c}`).join(", ");
			const fn = idx.unique ? "uniqueIndex" : "index";
			lines.push(`\t\t${fn}("${idx.name}").on(${cols}),`);
		}
		lines.push("\t],");
	}

	lines.push(");");
	return lines.join("\n");
}

function generateDrizzleSchema(tables: Record<string, TableDefinition>, schema: string): string {
	const imports = new Set<string>(["index", "uniqueIndex"]);
	if (schema !== "public") {
		imports.add("pgSchema");
	} else {
		imports.add("pgTable");
	}

	for (const def of Object.values(tables)) {
		for (const col of Object.values(def.columns)) {
			switch (col.type) {
				case "uuid":
					imports.add("uuid");
					break;
				case "text":
					imports.add("text");
					break;
				case "bigint":
					imports.add("bigint");
					break;
				case "integer":
					imports.add("integer");
					break;
				case "boolean":
					imports.add("boolean");
					break;
				case "timestamp":
					imports.add("timestamp");
					break;
				case "jsonb":
					imports.add("jsonb");
					break;
				case "serial":
					imports.add("serial");
					break;
				case "tsvector":
					imports.add("customType");
					break;
			}
		}
	}

	const sortedImports = [...imports].sort();
	const lines: string[] = [
		"// Auto-generated by summa generate — do not edit manually",
		`import { ${sortedImports.join(", ")} } from "drizzle-orm/pg-core";`,
	];

	if (schema !== "public") {
		lines.push("");
		lines.push(`export const summaSchema = pgSchema("${schema}");`);
	}

	lines.push("");

	for (const [name, def] of Object.entries(tables)) {
		lines.push(generateDrizzleTable(name, def, schema));
		lines.push("");
	}

	return lines.join("\n");
}

// =============================================================================
// PRISMA GENERATOR
// =============================================================================

const PRISMA_TYPE_MAP: Record<string, string> = {
	uuid: "String @default(uuid()) @db.Uuid",
	text: "String",
	bigint: "BigInt @default(0)",
	integer: "Int @default(0)",
	boolean: "Boolean @default(false)",
	timestamp: "DateTime @default(now()) @db.Timestamptz",
	jsonb: "Json",
	serial: "Int @default(autoincrement())",
	tsvector: 'Unsupported("tsvector")',
};

function generatePrismaModel(name: string, def: TableDefinition, schema: string): string {
	const tableName = toSnakeCase(name);
	const lines: string[] = [];

	lines.push(`model ${name} {`);

	for (const [colName, col] of Object.entries(def.columns)) {
		const baseType = PRISMA_TYPE_MAP[col.type] ?? "String";
		const optional = col.notNull ? "" : "?";
		const pk = col.primaryKey ? " @id" : "";
		const typeParts = baseType.split(" ");
		const prismaType = typeParts[0] + optional;
		const decorators = [pk, ...typeParts.slice(1).map((d) => ` ${d}`)].join("");

		lines.push(`  ${colName} ${prismaType}${decorators}`);

		// Add relation field for foreign keys
		if (col.references) {
			const refTable = capitalize(col.references.table);
			const relationField = colName.replace(/_id$/, "");
			if (relationField !== colName) {
				lines.push(
					`  ${relationField} ${refTable}? @relation(fields: [${colName}], references: [${col.references.column}])`,
				);
			}
		}
	}

	if (def.indexes && def.indexes.length > 0) {
		lines.push("");
		for (const idx of def.indexes) {
			const cols = idx.columns.join(", ");
			if (idx.unique) {
				lines.push(`  @@unique([${cols}], name: "${idx.name}")`);
			} else {
				lines.push(`  @@index([${cols}], name: "${idx.name}")`);
			}
		}
	}

	lines.push(`  @@map("${tableName}")`);
	if (schema !== "public") {
		lines.push(`  @@schema("${schema}")`);
	}
	lines.push("}");
	return lines.join("\n");
}

function generatePrismaSchema(tables: Record<string, TableDefinition>, schema: string): string {
	const lines: string[] = [
		"// Auto-generated by summa generate — do not edit manually",
		"",
		"generator client {",
		'  provider = "prisma-client-js"',
	];

	if (schema !== "public") {
		lines.push(`  previewFeatures = ["multiSchema"]`);
	}

	lines.push("}");
	lines.push("");
	lines.push("datasource db {");
	lines.push('  provider = "postgresql"');
	lines.push('  url      = env("DATABASE_URL")');

	if (schema !== "public") {
		lines.push(`  schemas  = ["${schema}"]`);
	}

	lines.push("}");
	lines.push("");

	for (const [name, def] of Object.entries(tables)) {
		lines.push(generatePrismaModel(name, def, schema));
		lines.push("");
	}

	return lines.join("\n");
}

// =============================================================================
// KYSELY GENERATOR
// =============================================================================

const KYSELY_TYPE_MAP: Record<string, string> = {
	uuid: "string",
	text: "string",
	bigint: "number",
	integer: "number",
	boolean: "boolean",
	timestamp: "Date",
	jsonb: "unknown",
	serial: "number",
	tsvector: "string",
};

function generateKyselyInterface(name: string, def: TableDefinition): string {
	const lines: string[] = [];

	lines.push(`export interface ${capitalize(name)}Table {`);

	for (const [colName, col] of Object.entries(def.columns)) {
		const tsType = KYSELY_TYPE_MAP[col.type] ?? "unknown";
		const optional = col.notNull ? "" : " | null";
		if (col.references) {
			lines.push(`  /** FK → ${col.references.table}.${col.references.column} */`);
		}
		lines.push(`  ${colName}: ${tsType}${optional};`);
	}

	lines.push("}");
	return lines.join("\n");
}

function generateKyselySchema(tables: Record<string, TableDefinition>, schema: string): string {
	const lines: string[] = ["// Auto-generated by summa generate — do not edit manually", ""];

	for (const [name, def] of Object.entries(tables)) {
		lines.push(generateKyselyInterface(name, def));
		lines.push("");
	}

	lines.push("export interface Database {");
	for (const name of Object.keys(tables)) {
		const tableName = toSnakeCase(name);
		const key = schema !== "public" ? `${schema}.${tableName}` : tableName;
		lines.push(`  "${key}": ${capitalize(name)}Table;`);
	}
	lines.push("}");

	return lines.join("\n");
}

// =============================================================================
// COMMAND
// =============================================================================

export const generateCommand = new Command("generate")
	.description("Generate database schema files from Summa table definitions")
	.option("--adapter <type>", "Target adapter: drizzle, prisma, or kysely")
	.option("--out <path>", "Output file path")
	.option("-y, --yes", "Skip confirmation prompts")
	.action(async (options: { adapter?: string; out?: string; yes?: boolean }) => {
		const parent = generateCommand.parent;
		const cwd: string = parent?.opts().cwd ?? process.cwd();
		const configPath: string | undefined = parent?.opts().config;

		p.intro(pc.bgCyan(pc.black(" summa generate ")));

		// Try to load config for plugin schemas and schema setting
		const config = await getConfig({ cwd, configPath });
		const schema = (config?.options?.schema as string) ?? "summa";

		// Import getSummaTables dynamically (resolved at runtime, not statically typed)
		let tables: Record<string, TableDefinition>;
		try {
			const mod = await import("summa/db" as string);
			const getSummaTables = mod.getSummaTables as (opts?: {
				plugins?: unknown[];
			}) => Record<string, TableDefinition>;
			tables = getSummaTables(config?.options ? { plugins: config.options.plugins } : undefined);
		} catch {
			p.log.error(
				`${pc.red("Could not load summa schema.")} ${pc.dim("Ensure summa is installed.")}`,
			);
			process.exitCode = 1;
			return;
		}

		// Determine adapter
		let adapter = options.adapter;
		if (!adapter && config?.options) {
			const db = config.options.database;
			if (typeof db === "object" && "id" in db) {
				adapter = (db as { id: string }).id;
			}
		}
		if (!adapter) {
			const result = await p.select({
				message: "Which adapter format?",
				options: [
					{ value: "drizzle", label: "Drizzle ORM" },
					{ value: "prisma", label: "Prisma" },
					{ value: "kysely", label: "Kysely" },
				],
			});
			if (p.isCancel(result)) {
				p.cancel("Cancelled.");
				process.exit(0);
			}
			adapter = result;
		}

		// Generate
		let output: string;
		let defaultFile: string;

		switch (adapter) {
			case "drizzle":
				output = generateDrizzleSchema(tables, schema);
				defaultFile = "summa.schema.ts";
				break;
			case "prisma":
				output = generatePrismaSchema(tables, schema);
				defaultFile = "summa.prisma";
				break;
			case "kysely":
				output = generateKyselySchema(tables, schema);
				defaultFile = "summa.schema.ts";
				break;
			default:
				p.log.error(`Unknown adapter: ${adapter}`);
				process.exitCode = 1;
				return;
		}

		const outPath = resolve(cwd, options.out ?? defaultFile);
		const outFileName = options.out ?? defaultFile;

		// Check if file already exists
		if (existsSync(outPath) && !options.yes) {
			// Check if content is the same
			const existing = readFileSync(outPath, "utf-8");
			if (existing === output) {
				p.log.success(`${pc.green("Schema is already up to date.")} No changes needed.`);
				p.outro(pc.dim(`${outFileName} is current.`));
				return;
			}

			const confirmed = await p.confirm({
				message: `${pc.bold(outFileName)} already exists. Overwrite?`,
				initialValue: false,
			});

			if (p.isCancel(confirmed) || !confirmed) {
				p.cancel("Generation cancelled.");
				process.exit(0);
			}
		}

		const s = p.spinner();
		s.start("Writing schema file");
		writeFileSync(outPath, output, "utf-8");
		s.stop(`Written to ${pc.bold(outFileName)}`);

		p.log.info(`${pc.dim(`${Object.keys(tables).length} tables generated for ${adapter}`)}`);
		p.outro(pc.dim("Review the generated file and adjust as needed."));
	});
