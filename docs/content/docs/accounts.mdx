---
title: Accounts
description: Create, freeze, close, and query accounts.
icon: Wallet
---

## Overview

Accounts are the fundamental building block in Summa. Every account belongs to a **holder** (identified by `holderId`) and tracks separate credit, debit, and pending balances using double-entry bookkeeping.

## Account Object

Every account returns the following fields:

```ts
interface Account {
  id: string;                    // UUID
  holderId: string;              // Your external user/entity ID
  holderType: HolderType;        // "individual" | "organization" | "system"
  status: AccountStatus;         // "active" | "frozen" | "closed"
  currency: string;              // ISO 4217 currency code
  balance: number;               // Settled balance (cents/paise)
  creditBalance: number;         // Lifetime credit total
  debitBalance: number;          // Lifetime debit total
  pendingCredit: number;         // Inflight credits
  pendingDebit: number;          // Held amounts (reduces available balance)
  allowOverdraft: boolean;
  overdraftLimit: number;              // Max negative balance allowed (0 = unlimited when overdraft enabled)
  accountType: AccountType | null;     // "asset" | "liability" | "equity" | "revenue" | "expense"
  accountCode: string | null;          // Unique chart-of-accounts code (e.g., "1000")
  parentAccountId: string | null;      // FK to parent account for hierarchy
  normalBalance: NormalBalance | null;  // "debit" | "credit" — auto-derived from accountType
  indicator: string | null;      // Human-friendly identifier
  freezeReason: string | null;
  frozenAt: Date | null;
  frozenBy: string | null;
  closedAt: Date | null;
  closedBy: string | null;
  closureReason: string | null;
  metadata: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
}
```

## Creating & Configuring Accounts

### Creating an Account

```ts
const account = await summa.accounts.create({
  holderId: "user_123",
  holderType: "individual",
  currency: "USD",
  allowOverdraft: false,
  indicator: "ACC-001",
  accountType: "asset",
  accountCode: "1100",
  metadata: { tier: "premium" },
});
```

<TypeTable
  type={{
    holderId: { type: "string", description: "Your external user/entity ID. One account per holderId.", required: true },
    holderType: { type: '"individual" | "organization" | "system"', description: "The type of account holder.", required: true },
    currency: { type: "string", description: "ISO 4217 code. Defaults to the instance currency.", default: "Instance currency" },
    allowOverdraft: { type: "boolean", description: "Allow balance to go negative.", default: "false" },
    overdraftLimit: { type: "number", description: "Maximum negative balance allowed (in smallest currency units). Only enforced when allowOverdraft is true. 0 = unlimited.", default: "0" },
    indicator: { type: "string", description: "Unique human-readable identifier (e.g., ACC-001)." },
    accountType: { type: '"asset" | "liability" | "equity" | "revenue" | "expense"', description: "Accounting classification. Determines the normal balance direction." },
    accountCode: { type: "string", description: "Unique account code (e.g., 1000, 2100). Used for chart of accounts ordering." },
    parentAccountId: { type: "string", description: "UUID of the parent account for hierarchical charts." },
    metadata: { type: "Record<string, unknown>", description: "Arbitrary key-value data stored with the account." },
  }}
/>

### Overdrafts

By default, transactions that would result in a negative balance are rejected with `INSUFFICIENT_BALANCE`. Enable overdrafts at the account level when creating the account:

```ts
const account = await summa.accounts.create({
  holderId: "merchant_1",
  holderType: "organization",
  currency: "USD",
  allowOverdraft: true,
});
```

<Callout type="info" title="Account-level only">
  Overdraft is controlled exclusively at the account level. All balance-reducing operations (debits, transfers, multi-destination transfers, and holds) respect the account's `allowOverdraft` and `overdraftLimit` settings uniformly.
</Callout>

### Overdraft Limits

When overdraft is enabled, you can set an `overdraftLimit` to cap how far the balance can go negative. The limit is specified in the smallest currency unit (cents/paise).

```ts
const account = await summa.accounts.create({
  holderId: "merchant_1",
  holderType: "organization",
  currency: "USD",
  allowOverdraft: true,
  overdraftLimit: 500_00,  // Balance can go down to -$500.00
});
```

<Callout type="info" title="Limit enforcement">
  The overdraft limit is enforced on all operations that reduce balance — debits, transfers, multi-destination transfers, and holds. If a transaction would push the balance below `-overdraftLimit`, it is rejected with `INSUFFICIENT_BALANCE`.
</Callout>

| `overdraftLimit` | `allowOverdraft` | Behavior |
|:-:|:-:|:--|
| `0` (default) | `false` | Balance cannot go below 0 |
| `0` | `true` | Unlimited overdraft — balance can go arbitrarily negative |
| `500_00` | `true` | Balance can go down to -50000 (e.g., -$500.00) |
| `500_00` | `false` | Limit is ignored — overdraft not allowed |

<Callout type="warn" title="Unlimited by default">
  When `allowOverdraft` is `true` and `overdraftLimit` is `0` (the default), the account has **no cap** on negative balance. Always set an explicit `overdraftLimit` in production to prevent unbounded exposure.
</Callout>

<Callout type="info" title="Need to bypass limits?">
  For chargebacks, network-initiated adjustments, or regulatory debits that must succeed regardless of balance, use [`forceDebit`](/docs/transactions#force-debit) or [`forceTransfer`](/docs/transactions#force-transfer). They skip all balance and overdraft checks.
</Callout>

### Updating Overdraft Settings

You can update overdraft settings on a live account without recreating it:

```ts
await summa.accounts.updateOverdraft({
  holderId: "merchant_1",
  allowOverdraft: true,
  overdraftLimit: 1000_00,  // $1,000.00
});
```

<TypeTable
  type={{
    holderId: { type: "string", description: "Holder ID of the account to update.", required: true },
    allowOverdraft: { type: "boolean", description: "Enable or disable overdraft.", required: true },
    overdraftLimit: { type: "number", description: "New overdraft limit in smallest currency units.", default: "0" },
  }}
/>

<Callout type="info" title="Closed accounts">
  Overdraft settings cannot be updated on closed accounts. Frozen accounts can be updated.
</Callout>

### Account Indicators

Indicators are optional, unique human-friendly identifiers for accounts:

```ts
const account = await summa.accounts.create({
  holderId: "user_123",
  holderType: "individual",
  currency: "USD",
  indicator: "ACC-00001",
});
```

### Metadata

Accounts support arbitrary key-value metadata for storing application-specific data:

```ts
const account = await summa.accounts.create({
  holderId: "user_123",
  holderType: "individual",
  currency: "USD",
  metadata: {
    tier: "premium",
    signupSource: "referral",
    kycVerified: true,
  },
});
```

## Account Lifecycle

### Freezing an Account

Frozen accounts reject all transactions and holds but preserve their state. Useful for fraud investigations or compliance holds.

```ts
await summa.accounts.freeze({
  holderId: "user_123",
  reason: "Suspicious activity — under review",
  frozenBy: "admin@example.com",
});
```

<Callout type="warn" title="Frozen accounts">
  Attempting any transaction on a frozen account throws `ACCOUNT_FROZEN` error (HTTP 403).
</Callout>

### Unfreezing

```ts
await summa.accounts.unfreeze({
  holderId: "user_123",
  unfrozenBy: "admin@example.com",
  reason: "Customer verified identity",  // Optional
});
```

### Closing an Account

<Callout type="error" title="Permanent action">
  Closing is **permanent** and cannot be undone. If there's a remaining balance, you must sweep funds to another account.
</Callout>

```ts
await summa.accounts.close({
  holderId: "user_123",
  closedBy: "admin@example.com",
  reason: "Customer request",
  transferToHolderId: "treasury",  // Optional — sweep remaining balance
});
```

Attempting any operation on a closed account throws `ACCOUNT_CLOSED` error (HTTP 403).

## Querying Accounts

### Getting an Account

<Tabs items={["By holder ID", "By internal ID"]}>
<Tab value="By holder ID">

```ts
const account = await summa.accounts.get("user_123");
```

</Tab>
<Tab value="By internal ID">

```ts
const account = await summa.accounts.getById(accountId);
```

</Tab>
</Tabs>

### Checking Balance

```ts
const balance = await summa.accounts.getBalance("user_123");
```

<TypeTable
  type={{
    balance: { type: "number", description: "Settled balance (credits - debits)." },
    creditBalance: { type: "number", description: "Lifetime credit total." },
    debitBalance: { type: "number", description: "Lifetime debit total." },
    pendingCredit: { type: "number", description: "Inflight credits." },
    pendingDebit: { type: "number", description: "Held amounts." },
    availableBalance: { type: "number", description: "balance - pendingDebit — what can be spent." },
    currency: { type: "string", description: "ISO 4217 currency code." },
  }}
/>

<Callout type="info" title="Available balance">
  `availableBalance` is the key field — it's what the user can actually spend, accounting for pending holds.
</Callout>

### Listing Accounts

```ts
const result = await summa.accounts.list({
  page: 1,
  perPage: 20,
  status: "active",
  holderType: "individual",
  search: "user_",
});

// result.accounts — Account[]
// result.hasMore  — boolean
// result.total    — number
```

## Chart of Accounts

Summa supports full accounting primitives through the `chartOfAccounts` namespace. Assign an `accountType` when creating accounts to classify them as asset, liability, equity, revenue, or expense.

### Account Types & Normal Balance

The `normalBalance` is automatically derived from `accountType`:

| Account Type | Normal Balance | Increases with |
|-------------|---------------|----------------|
| `asset` | `debit` | Debits |
| `expense` | `debit` | Debits |
| `liability` | `credit` | Credits |
| `equity` | `credit` | Credits |
| `revenue` | `credit` | Credits |

### Account Hierarchy

Create parent–child relationships for hierarchical charts:

```ts
// Parent account
const cashAccounts = await summa.accounts.create({
  holderId: "cash_parent",
  holderType: "system",
  currency: "USD",
  accountType: "asset",
  accountCode: "1000",
});

// Child account
const bankAccount = await summa.accounts.create({
  holderId: "bank_checking",
  holderType: "system",
  currency: "USD",
  accountType: "asset",
  accountCode: "1010",
  parentAccountId: cashAccounts.id,
});
```

### Querying the Chart

```ts
// Get all accounts of a specific type
const assets = await summa.chartOfAccounts.getByType("asset");

// Get child accounts
const children = await summa.chartOfAccounts.getChildren(parentAccountId);

// Get the full hierarchy tree
const tree = await summa.chartOfAccounts.getHierarchy();

// Validate the accounting equation (Assets = Liabilities + Equity)
const result = await summa.chartOfAccounts.validateEquation();
console.log(result.balanced);   // true
console.log(result.assets);     // total asset balance
console.log(result.liabilities); // total liability balance
console.log(result.equity);     // total equity balance
```

<Callout type="info" title="Backward compatible">
  All chart-of-accounts fields are optional. Existing accounts without `accountType` continue to work as before — they simply won't appear in chart-of-accounts queries.
</Callout>
