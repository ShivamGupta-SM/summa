---
title: Events
description: Entry-based hash chains, tamper-proof verification, and the immutable audit trail.
icon: QueueList
---

## Overview

In Summa, **entries are events** — every financial mutation (credit, debit, transfer, hold) produces double-entry journal entries that also serve as the immutable, tamper-proof event log. There is no separate event store.

Each entry includes an **HMAC-SHA256 hash** computed from the entry data and the previous entry's hash (per-account), forming a cryptographic chain. If any entry is tampered with, the chain breaks — detected immediately on the next read.

## Entry Structure

Every entry stored in Summa follows the `StoredEvent` interface:

```ts
interface StoredEvent {
  id: string;                    // UUID
  transferId: string;            // The transfer that created this entry
  accountId: string;             // The account this entry belongs to
  entryType: string;             // "CREDIT" or "DEBIT"
  amount: number;                // Amount in minor units
  currency: string;              // ISO 4217 currency code
  balanceBefore: number | null;  // Balance before this entry
  balanceAfter: number | null;   // Balance after this entry
  accountVersion: number | null; // Account version after this entry
  sequenceNumber: number;        // Global per-ledger sequence
  hash: string;                  // HMAC-SHA256 hash (or SHA-256 if no secret)
  prevHash: string | null;       // Previous entry's hash in this account's chain
  createdAt: Date;
}
```

## Querying Events

### By account

Get all entries for a specific account:

```ts
// All entries for an account
const events = await summa.events.getForAccount(accountId);
```

### By transfer

Get all entries produced by a specific transfer:

```ts
// All entries for a transfer (both sides of the double-entry)
const events = await summa.events.getForTransfer(transferId);
```

### By correlation

All entries in a single operation share a `correlationId` via their transfer. For example, a transfer creates entries on both the source and destination accounts — they share the same correlationId:

```ts
const events = await summa.events.getByCorrelation(transfer.correlationId);
// Returns: all entries produced by transfers with this correlation ID
```

## Tamper-Proofing

Summa uses multiple layers to ensure ledger integrity:

### HMAC-SHA256 Hash Chain

Every entry is hashed with the previous entry's hash (for the same account) using **HMAC-SHA256** (when `advanced.hmacSecret` is configured). Without the secret key, an attacker with database access cannot recompute valid hashes — any modification is cryptographically detectable.

```ts
const summa = createSumma({
  database: adapter,
  advanced: {
    hmacSecret: process.env.SUMMA_HMAC_SECRET,  // Strong random string
  },
});
```

<Callout type="warn" title="Always set hmacSecret in production">
  Without `hmacSecret`, hash chains use plain SHA-256 — an attacker with database access could recompute valid hashes after tampering. Summa logs a warning at startup if this is not configured.
</Callout>

### Read-Time Hash Verification

By default, Summa verifies the entry hash chain **on every read** — not just during manual verification or daily reconciliation. Any tampered entry is detected immediately when accessed.

```ts
// Enabled by default — disable only for maximum read throughput
advanced: {
  verifyEntryHashOnRead: true,  // default
}
```

When a hash mismatch is detected on read, Summa throws a `SummaError` with code `CHAIN_INTEGRITY_VIOLATION`.

### Balance Checksums

Every `account` row includes an HMAC-SHA256 checksum computed from the balance fields (`balance`, `credit_balance`, `debit_balance`, `pending_debit`, `pending_credit`, `version`). Balances are updated in-place but protected by the checksum — any direct SQL tampering of balance columns is immediately detected.

### Database-Level Immutability

Beyond application-level checks, Summa enforces immutability at the PostgreSQL level. The `summa migrate push` command automatically creates triggers that block UPDATE and DELETE operations on immutable financial tables:

- `entry`
- `block_checkpoint`, `merkle_node`
- `entity_status_log`

Even with direct database access, any attempt to modify or delete these rows raises an exception.

### External Anchoring

Use the reconciliation plugin's `onBlockCheckpoint` callback to anchor block hashes to an external store (S3, blockchain, separate database). This provides cryptographic proof that the ledger state at a given point was not altered retroactively.

```ts
import { reconciliation } from "@summa-ledger/summa/plugins";

plugins: [
  reconciliation({
    onBlockCheckpoint: async (anchor) => {
      // Write to S3, a separate database, or a blockchain
      await externalStore.put(`block-${anchor.blockSequence}`, {
        blockHash: anchor.blockHash,
        merkleRoot: anchor.merkleRoot,
        entryCount: anchor.entryCount,
        fromEntrySequence: anchor.fromEntrySequence,
        toEntrySequence: anchor.toEntrySequence,
        timestamp: anchor.timestamp,
      });
    },
  }),
]
```

Later, verify that the stored block hash matches:

```ts
const result = await summa.events.verifyExternalAnchor(
  blockSequence,
  externallyStoredBlockHash,
);

console.log(result.valid);       // true if hashes match
console.log(result.storedHash);  // the hash in the database
```

### Merkle Proofs

Summa builds a Merkle tree during each block checkpoint, enabling O(log n) inclusion proofs for any entry. Generate a compact proof for a single entry and verify it independently:

```ts
// Generate a proof for a specific entry (O(log n) sibling hashes)
const proof = await summa.events.generateProof(entryId);
// proof = { leafHash, leafIndex, siblings, root, blockId, blockSequence }

// Verify the proof cryptographically + cross-check against stored block root
const result = await summa.events.verifyProof(proof, proof.blockId);
console.log(result.valid);     // true if proof is cryptographically valid
console.log(result.rootMatch); // true if root matches stored block checkpoint
```

For a block with 1M entries, the proof contains ~20 sibling hashes — enough to recompute the root without scanning the entire block.

## Hash Chain Verification

Verify the integrity of the entry chain for a specific account:

```ts
const result = await summa.events.verifyAccountChain(accountId);

console.log(result.valid);           // true if chain is intact
console.log(result.eventCount);      // number of entries verified
console.log(result.brokenAtVersion); // version where chain broke (if invalid)
```

The verification re-computes every hash from the entry data and checks that each `hash` matches the next entry's `prevHash`.

### Checkpoint-Aware Verification

`verifyAccountChain()` scans every entry from the beginning — O(all entries). For accounts with millions of entries, use the checkpoint-aware variant that skips entries already covered by sealed block checkpoints:

```ts
import { verifyHashChainFromCheckpoint } from "@summa-ledger/summa/infrastructure";

const result = await verifyHashChainFromCheckpoint(
  ctx,
  "account",
  accountId,
  ledgerId,
);

console.log(result.valid);                // true if chain is intact
console.log(result.eventCount);           // entries actually scanned
console.log(result.skippedViaCheckpoint); // entries skipped (already sealed)
console.log(result.brokenAtVersion);      // version where chain broke (if invalid)
```

This finds the latest sealed `block_checkpoint`, gets the last entry hash it covers, and verifies only entries after that point. Falls back to a full scan if no checkpoints exist.

The reconciliation plugin uses this automatically for hash chain verification.

### `getLatestSealedSequence`

Get the highest entry sequence number covered by a sealed block checkpoint:

```ts
import { getLatestSealedSequence } from "@summa-ledger/summa/infrastructure";

const seq = await getLatestSealedSequence(ctx, ledgerId);
// Returns 0 if no checkpoints exist
```

Useful for determining how much of the entry log is "sealed" and safe for partition detachment.

## CLI Verification

The CLI provides comprehensive integrity checks:

```bash
# Verify everything (balances + hash chain + merkle)
npx summa verify

# Verify hash chain only
npx summa verify --chain

# Verify double-entry balances only
npx summa verify --balances

# Verify Merkle tree integrity
npx summa verify --merkle
```

**Hash chain checks:**
- Block checkpoint chain linkage (`prev_block_hash` matches)
- Entry hash chain per account (samples up to 50 accounts)

**Balance checks:**
- Per-transfer double-entry balance (every transfer must have equal debits and credits)
- Global balance invariant (sum of all account balances = 0)
- Duplicate entry detection

**Merkle tree checks:**
- Recompute Merkle root from entry hashes and compare with stored root
- Verify leaf node counts match entry counts per block

## Transaction Isolation

All entry operations run within `READ COMMITTED` isolation level transactions with configurable statement and lock timeouts. This ensures consistency without risking deadlocks under concurrent load.
