---
title: Events
description: Event sourcing, hash chain verification, and the immutable audit trail.
icon: QueueList
---

## Overview

Summa is **event-sourced** — every mutation (account creation, transaction, hold, etc.) produces an immutable event stored in an append-only log. Events are never updated or deleted.

Each event includes an **HMAC-SHA256 hash** computed from the event data and the previous event's hash, forming a cryptographic chain. If any event is tampered with, the chain breaks — detected immediately on the next read.

## Event Structure

Every event stored in Summa follows the `StoredEvent` interface:

```ts
interface StoredEvent {
  id: string;                    // UUID
  sequenceNumber: number;        // Global sequence
  aggregateType: string;         // "account", "transaction", "hold"
  aggregateId: string;           // The entity's ID
  aggregateVersion: number;      // Per-aggregate version counter
  eventType: string;             // e.g. "AccountCreated", "TransactionPosted"
  eventData: Record<string, unknown>;  // Event payload
  correlationId: string;         // Groups related events
  hash: string;                  // HMAC-SHA256 hash (or SHA-256 if no secret)
  prevHash: string | null;       // Previous event's hash (null for first)
  createdAt: Date;
}
```

## Event Types

### Account Events

| Event | When |
|-------|------|
| `AccountCreated` | New account is created |
| `AccountFrozen` | Account is frozen |
| `AccountUnfrozen` | Account is unfrozen |
| `AccountClosed` | Account is permanently closed |

### Transaction Events

| Event | When |
|-------|------|
| `TransactionInitiated` | Transaction begins processing |
| `TransactionPosted` | Transaction completes and balances are updated |
| `TransactionReversed` | Transaction is refunded |

### Hold Events

| Event | When |
|-------|------|
| `HoldCreated` | New hold is placed on an account |
| `HoldCommitted` | Hold is captured into a posted transaction |
| `HoldVoided` | Hold is released without charging |
| `HoldExpired` | Hold passed its expiration time |

### Scheduled Transaction Events

| Event | When |
|-------|------|
| `ScheduledTransactionCreated` | Future transaction is scheduled |
| `ScheduledTransactionCancelled` | Scheduled transaction is cancelled |
| `ScheduledTransactionProcessing` | Worker picks up the scheduled transaction |
| `ScheduledTransactionCompleted` | Scheduled transaction succeeds |
| `ScheduledTransactionRescheduled` | Scheduled transaction is retried later |
| `ScheduledTransactionFailed` | Scheduled transaction fails permanently |

## Querying Events

### By aggregate

Get all events for a specific entity:

```ts
// All events for an account
const events = await summa.events.getForAggregate("account", accountId);

// All events for a transaction
const events = await summa.events.getForAggregate("transaction", txnId);

// All events for a hold
const events = await summa.events.getForAggregate("hold", holdId);
```

### By correlation

All events in a single operation share a `correlationId`. For example, a transfer creates events on both the source and destination accounts — they share the same correlationId:

```ts
const events = await summa.events.getByCorrelation(txn.correlationId);
// Returns: TransactionInitiated, TransactionPosted, entry events, etc.
```

## Tamper-Proofing

Summa uses multiple layers to ensure ledger integrity:

### HMAC-SHA256 Hash Chain

Every event is hashed with the previous event's hash using **HMAC-SHA256** (when `advanced.hmacSecret` is configured). Without the secret key, an attacker with database access cannot recompute valid hashes — any modification is cryptographically undetectable without the key.

```ts
const summa = createSumma({
  database: adapter,
  advanced: {
    hmacSecret: process.env.SUMMA_HMAC_SECRET,  // Strong random string
  },
});
```

<Callout type="warn" title="Always set hmacSecret in production">
  Without `hmacSecret`, hash chains use plain SHA-256 — an attacker with database access could recompute valid hashes after tampering. Summa logs a warning at startup if this is not configured.
</Callout>

### Read-Time Hash Verification

By default, Summa verifies the hash chain **on every read** — not just during manual verification or daily reconciliation. Any tampered event is detected immediately when accessed.

```ts
// Enabled by default — disable only for maximum read throughput
advanced: {
  verifyHashOnRead: true,  // default
}
```

When a hash mismatch is detected on read, Summa throws a `SummaError` with code `CHAIN_INTEGRITY_VIOLATION`.

### Balance Checksums

Every `account_balance_version` row includes an HMAC-SHA256 checksum computed from the balance fields (`balance`, `credit_balance`, `debit_balance`, `pending_debit`, `pending_credit`, `version`). Since balances are append-only (each change creates a new version row), direct SQL tampering is both detected by the checksum and blocked by database-level immutability triggers.

### Database-Level Immutability

Beyond application-level checks, Summa enforces immutability at the PostgreSQL level. The `summa migrate push` command automatically creates triggers that block UPDATE and DELETE operations on all financial tables:

- `account_balance`, `account_balance_version`
- `transaction_record`, `transaction_status`
- `entry_record`, `ledger_event`
- `block_checkpoint`, `merkle_node`
- `entity_status_log`
- `system_account`, `system_account_version`

Even with direct database access, any attempt to modify or delete these rows raises an exception.

### External Anchoring

Use the reconciliation plugin's `onBlockCheckpoint` callback to anchor block hashes to an external store (S3, blockchain, separate database). This provides cryptographic proof that the ledger state at a given point was not altered retroactively.

```ts
import { reconciliation } from "summa/plugins";

plugins: [
  reconciliation({
    onBlockCheckpoint: async (anchor) => {
      // Write to S3, a separate database, or a blockchain
      await externalStore.put(`block-${anchor.blockSequence}`, {
        blockHash: anchor.blockHash,
        merkleRoot: anchor.merkleRoot,
        eventCount: anchor.eventCount,
        fromEventSequence: anchor.fromEventSequence,
        toEventSequence: anchor.toEventSequence,
        timestamp: anchor.timestamp,
      });
    },
  }),
]
```

Later, verify that the stored block hash matches:

```ts
const result = await summa.events.verifyExternalAnchor(
  blockSequence,
  externallyStoredBlockHash,
);

console.log(result.valid);       // true if hashes match
console.log(result.storedHash);  // the hash in the database
```

### Merkle Proofs

Summa builds a Merkle tree during each block checkpoint, enabling O(log n) inclusion proofs for any event. Generate a compact proof for a single event and verify it independently:

```ts
// Generate a proof for a specific event (O(log n) sibling hashes)
const proof = await summa.events.generateProof(eventId);
// proof = { leafHash, leafIndex, siblings, root, blockId, blockSequence }

// Verify the proof cryptographically + cross-check against stored block root
const result = await summa.events.verifyProof(proof, proof.blockId);
console.log(result.valid);     // true if proof is cryptographically valid
console.log(result.rootMatch); // true if root matches stored block checkpoint
```

For a block with 1M events, the proof contains ~20 sibling hashes — enough to recompute the root without scanning the entire block.

## Hash Chain Verification

Verify the integrity of the event chain for any aggregate:

```ts
const result = await summa.events.verifyChain("account", accountId);

console.log(result.valid);           // true if chain is intact
console.log(result.eventCount);      // number of events verified
console.log(result.brokenAtVersion); // version where chain broke (if invalid)
```

The verification re-computes every hash from the event data and checks that each `hash` matches the next event's `prevHash`.

### Checkpoint-Aware Verification

`verifyHashChain()` scans every event from the beginning — O(all events). For ledgers with millions of events, use the checkpoint-aware variant that skips events already covered by sealed block checkpoints:

```ts
import { verifyHashChainFromCheckpoint } from "summa/infrastructure";

const result = await verifyHashChainFromCheckpoint(
  ctx,
  "account",
  accountId,
  ledgerId,
);

console.log(result.valid);                // true if chain is intact
console.log(result.eventCount);           // events actually scanned
console.log(result.skippedViaCheckpoint); // events skipped (already sealed)
console.log(result.brokenAtVersion);      // version where chain broke (if invalid)
```

This finds the latest sealed `block_checkpoint`, gets the last event hash it covers, and verifies only events after that point. Falls back to a full scan if no checkpoints exist.

The reconciliation plugin uses this automatically for Step 5 (hash chain verification).

### `getLatestSealedSequence`

Get the highest event sequence number covered by a sealed block checkpoint:

```ts
import { getLatestSealedSequence } from "summa/infrastructure";

const seq = await getLatestSealedSequence(ctx, ledgerId);
// Returns 0 if no checkpoints exist
```

Useful for determining how much of the event log is "sealed" and safe for partition detachment.

## CLI Verification

The CLI provides comprehensive integrity checks:

```bash
# Verify everything (balances + hash chain + merkle)
npx summa verify

# Verify hash chain only
npx summa verify --chain

# Verify double-entry balances only
npx summa verify --balances

# Verify Merkle tree integrity
npx summa verify --merkle
```

**Hash chain checks:**
- Block checkpoint chain linkage (`prev_block_hash` matches)
- Event hash chain per aggregate (samples up to 50 aggregates)

**Balance checks:**
- Per-transaction double-entry balance (every transaction must have equal debits and credits)
- Global balance invariant (user + system + hot accounts = 0)
- Duplicate entry detection

**Merkle tree checks:**
- Recompute Merkle root from event hashes and compare with stored root
- Verify leaf node counts match event counts per block

## Disabling Event Sourcing

For testing or high-throughput scenarios where you don't need the audit trail:

```ts
const summa = createSumma({
  database: adapter,
  advanced: {
    enableEventSourcing: false,  // Don't write events
  },
});
```

This reduces write amplification but loses the audit trail and chain verification capability.

<Callout type="warn" title="Hash chain cannot be disabled">
  The HMAC-SHA256 hash chain is always enabled when event sourcing is on. It is critical for tamper detection and integrity verification. All events are hashed with their predecessor's hash, forming a verifiable chain per aggregate.
</Callout>

## Transaction Isolation

All event store operations run within `READ COMMITTED` isolation level transactions with configurable statement and lock timeouts. This ensures consistency without risking deadlocks under concurrent load.
