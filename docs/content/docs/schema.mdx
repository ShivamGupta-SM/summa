---
title: Database Schema
description: Complete reference for all Summa database tables, columns, and indexes.
icon: CircleStack
---

## Overview

Summa creates and manages its own database tables. All tables live in a configurable PostgreSQL schema (default: `"summa"`), keeping them isolated from your application tables.

```ts
const summa = createSumma({
  database: adapter,
  schema: "summa", // PostgreSQL schema name (default)
});
```

Tables are created automatically via `summa migrate push` or through your ORM's migration tools (see [Adapters](/docs/adapters/drizzle#migrations)).

## Core Tables

Summa uses **10 core tables** — a minimal, TigerBeetle-inspired architecture where entries are the single source of truth.

### ledger

Stores tenant/namespace metadata for multi-tenancy. Each ledger is an isolated namespace with its own accounts, transfers, and entries.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `name` | VARCHAR(255) | Ledger name |
| `metadata` | JSONB | Custom metadata |
| `created_at` | TIMESTAMPTZ | Creation time |

---

### account

Unified account table — both user and system accounts live here. System accounts are accounts with `is_system = true`. Balances are mutable (updated in-place) and protected by HMAC checksums and optimistic locking.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `ledger_id` | UUID | FK to `ledger` — scopes accounts per tenant |
| `holder_id` | VARCHAR(255) | User or entity identifier |
| `holder_type` | VARCHAR(100) | `"individual"`, `"business"`, `"organization"`, etc. |
| `currency` | CHAR(3) | ISO 4217 currency code |
| `is_system` | BOOLEAN | `true` for system accounts (`@World`, `@Fees`, etc.) |
| `system_identifier` | TEXT | Unique system identifier (e.g., `"@World"`) — `NULL` for user accounts |
| `name` | TEXT | Display name |
| `account_type` | VARCHAR(20) | Chart of Accounts type (asset, liability, etc.) |
| `account_code` | VARCHAR(50) | GL account code (unique) |
| `parent_account_id` | UUID | Hierarchical parent account |
| `normal_balance` | VARCHAR(10) | `"debit"` or `"credit"` |
| `indicator` | TEXT | Account indicator |
| `allow_overdraft` | BOOLEAN | Whether overdraft is allowed |
| `overdraft_limit` | BIGINT | Max negative balance allowed in minor units |
| `metadata` | JSONB | Custom fields |
| `created_at` | TIMESTAMPTZ | Creation time |
| | | **Mutable balance state** |
| `balance` | BIGINT | Net balance in minor units |
| `credit_balance` | BIGINT | Total lifetime credits |
| `debit_balance` | BIGINT | Total lifetime debits |
| `pending_credit` | BIGINT | Credits held (not yet committed) |
| `pending_debit` | BIGINT | Debits held (not yet committed) |
| `version` | INTEGER | Monotonically increasing — optimistic lock |
| `status` | VARCHAR(20) | `"active"`, `"frozen"`, or `"closed"` |
| `checksum` | VARCHAR(64) | HMAC balance integrity checksum |
| `freeze_reason` | TEXT | Reason for freeze |
| `frozen_at` / `frozen_by` | TIMESTAMPTZ / VARCHAR | Freeze metadata |
| `closed_at` / `closed_by` / `closure_reason` | — | Closure metadata |

**Key indexes:** `(ledger_id, holder_id, currency)` unique, `(ledger_id, system_identifier)` unique where not null, `(account_type)`, `(parent_account_id)`

**Tamper detection:** `checksum` = HMAC-SHA256 of (balance + credit_balance + debit_balance + pending_debit + pending_credit + version). Verified on every read.

**Optimistic locking:** `UPDATE account SET version = version + 1 WHERE id = $1 AND version = $expected`. Concurrent writes to the same account are detected and retried.

---

### transfer

Core transfer/transaction data. Status is a mutable column — status transitions are logged in `entity_status_log`.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `ledger_id` | UUID | FK to `ledger` — scopes transfers per tenant |
| `type` | VARCHAR(50) | Transfer type (`"credit"`, `"debit"`, `"transfer"`, `"journal"`, etc.) |
| `status` | VARCHAR(20) | `"inflight"`, `"posted"`, `"voided"`, `"expired"`, `"reversed"` |
| `reference` | VARCHAR(255) | Unique reference / idempotency key |
| `amount` | BIGINT | Amount in minor units |
| `currency` | CHAR(3) | Currency |
| `description` | TEXT | Transfer memo |
| `source_account_id` | UUID | Sending account (user or system) |
| `destination_account_id` | UUID | Receiving account (user or system) |
| `is_hold` | BOOLEAN | Whether this is a hold (not actual) |
| `hold_expires_at` | TIMESTAMPTZ | Hold expiry time |
| `parent_id` | UUID | Parent transfer (for refunds/reversals) |
| `is_reversal` | BOOLEAN | Whether this is a reversal |
| `committed_amount` | BIGINT | Amount committed from hold |
| `refunded_amount` | BIGINT | Amount refunded |
| `correlation_id` | UUID | Request correlation ID |
| `metadata` | JSONB | Custom metadata |
| `effective_date` | TIMESTAMPTZ | Effective date |
| `posted_at` | TIMESTAMPTZ | When posted |
| `created_at` | TIMESTAMPTZ | Creation time |

**Key indexes:** `(ledger_id, reference)` unique, `(type)`, `(source_account_id)`, `(destination_account_id)`, `(hold_expires_at)`, `(parent_id)`, `(created_at)`

---

### entry

The double-entry journal **and** the tamper-proof event log in one table. Every transfer produces exactly balanced `DEBIT` and `CREDIT` entries. Each entry carries hash chain fields — entries ARE events.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `transfer_id` | UUID | FK to `transfer` |
| `account_id` | UUID | FK to `account` (user or system) |
| `entry_type` | VARCHAR(10) | `"DEBIT"` or `"CREDIT"` |
| `amount` | BIGINT | Amount in minor units |
| `currency` | CHAR(3) | Currency |
| `balance_before` / `balance_after` | BIGINT | Balance snapshots (NULL for hot/system entries) |
| `account_version` | INTEGER | Account version after this entry (NULL for hot) |
| | | **Hash chain fields** |
| `sequence_number` | BIGSERIAL | Global per-ledger sequence |
| `hash` | VARCHAR(64) | SHA-256/HMAC hash of this entry |
| `prev_hash` | VARCHAR(64) | Previous entry's hash in this account's chain |
| | | **FX fields** |
| `original_amount` / `original_currency` | — | Pre-FX conversion values |
| `exchange_rate` | BIGINT | FX rate (scaled to 6 decimals) |
| `effective_date` | TIMESTAMPTZ | Effective date |
| `created_at` | TIMESTAMPTZ | Creation time |

**Key indexes:** `(transfer_id)`, `(account_id)`, `(account_id, account_version)` unique where not null, `(sequence_number)` unique

**Hash chain:** Each entry's hash = SHA-256(prev_hash_for_this_account + entry_data). Per-account chains provide natural verification — "verify all entries for account X are untampered." A global `sequence_number` enables block checkpoints across all accounts.

---

### block_checkpoint

Block-based hash chain checkpoints (Azure SQL Ledger pattern). Enables O(new entries) verification instead of O(all entries).

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `ledger_id` | UUID | FK to `ledger` — block checkpoints are per-ledger |
| `block_sequence` | BIGSERIAL | Block ordering |
| `from_entry_sequence` / `to_entry_sequence` | BIGINT | Entry range in this block |
| `event_count` | INTEGER | Number of entries |
| `events_hash` | VARCHAR(64) | SHA-256 of sorted entry hashes |
| `block_hash` | VARCHAR(64) | SHA-256 of `prev_block_hash + events_hash` |
| `prev_block_id` / `prev_block_hash` | — | Link to previous block |
| `merkle_root` | VARCHAR(64) | Merkle tree root hash |
| `tree_depth` | INTEGER | Depth of the Merkle tree for this block |

---

### merkle_node

**Append-only** — stores the Merkle tree structure for each block checkpoint. Enables O(log n) inclusion proofs for any entry.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `block_id` | UUID | FK to `block_checkpoint` |
| `level` | INTEGER | 0 = leaf, max = root |
| `position` | INTEGER | Position within the level |
| `hash` | VARCHAR(64) | Node hash |
| `left_child_id` | UUID | Left child node |
| `right_child_id` | UUID | Right child node |
| `entry_id` | UUID | Entry ID (leaf nodes only) |
| `created_at` | TIMESTAMPTZ | Creation time |

**Key indexes:** `(block_id, level, position)` unique

---

### entity_status_log

**Append-only** — tracks status transitions for transfers and plugin workflow entities. Provides full audit trail for every status change.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `entity_type` | TEXT | Entity type (e.g., `transfer`, `approval_request`, `import_batch`) |
| `entity_id` | UUID | Entity ID |
| `status` | TEXT | The new status |
| `previous_status` | TEXT | Previous status (for audit) |
| `reason` | TEXT | Why this transition happened |
| `metadata` | JSONB | Status-specific data |
| `created_at` | TIMESTAMPTZ | Transition timestamp |

**Key indexes:** `(entity_type, entity_id, created_at DESC)` for latest status lookup

---

### idempotency_key

Prevents duplicate transactions. Keys expire after 24 hours by default.

| Column | Type | Description |
|--------|------|-------------|
| `ledger_id` | UUID | FK to `ledger` — same key OK across different ledgers |
| `key` | VARCHAR(255) | The idempotency key (composite PK with `ledger_id`) |
| `reference` | VARCHAR(255) | Transfer reference |
| `result_data` | JSONB | Cached response |
| `expires_at` | TIMESTAMPTZ | Expiry (default: NOW + 24h) |

---

### worker_lease

Distributed worker coordination. Prevents duplicate background job execution across instances.

| Column | Type | Description |
|--------|------|-------------|
| `worker_id` | VARCHAR(100) | Primary key — worker name |
| `lease_holder` | VARCHAR(100) | Current holder instance |
| `lease_until` | TIMESTAMPTZ | Lease expiry |
| `acquired_at` | TIMESTAMPTZ | When acquired |

---

### summa_migration

Tracks applied schema migrations.

| Column | Type | Description |
|--------|------|-------------|
| `id` | INTEGER | Primary key |
| `name` | TEXT | Migration name |
| `hash` | TEXT | Migration content hash |
| `applied_at` | TIMESTAMPTZ | When applied |

## Plugin Tables

Plugins create their own tables when enabled. These are only created if you include the plugin in your configuration.

### Hot Accounts

| Table | Purpose |
|-------|---------|
| `hot_account_failed_sequence` | Hot account batch failure tracking |

### Outbox

| Table | Purpose |
|-------|---------|
| `outbox` | Transactional outbox for reliable event publishing |

### Velocity Limits

| Table | Purpose |
|-------|---------|
| `account_limit` | Per-account velocity limits |

### Scheduled Transactions

| Table | Purpose |
|-------|---------|
| `scheduled_transaction` | Recurring / future-dated transactions |

### Reconciliation

| Table | Purpose |
|-------|---------|
| `reconciliation_result` | Daily reconciliation run results |
| `reconciliation_watermark` | Incremental reconciliation tracking |

### Snapshots

| Table | Purpose |
|-------|---------|
| `account_snapshot` | End-of-day balance snapshots |

### DLQ Manager

| Table | Purpose |
|-------|---------|
| `dead_letter_queue` | Failed outbox events for manual recovery |

### Audit Log

| Table | Purpose |
|-------|---------|
| `audit_log` | Immutable audit trail — operation, params, actor, HMAC hash, timestamp |

### Accrual Accounting

| Table | Purpose |
|-------|---------|
| `accrual_schedule` | Revenue/expense recognition schedules with amounts and progress |
| `accrual_posting` | Individual period postings with dates, status, and `transfer_id` |

### FX Engine

| Table | Purpose |
|-------|---------|
| `fx_rate_cache` | Cached exchange rates with TTL |
| `fx_rate_quote` | Temporary FX quotes (active → used/expired) |
| `fx_gain_loss` | Realized FX gains and losses per transfer |

### Approval Workflow

| Table | Purpose |
|-------|---------|
| `approval_rule` | Approval trigger rules (amount thresholds, account types) |
| `approval_request` | Pending approval requests with status and approver tracking |

### Batch Import

| Table | Purpose |
|-------|---------|
| `import_batch` | Batch metadata (status, item counts, creator) |
| `batch_item` | Individual items with validation status and posted transfer ID |

### GL Sub-Ledger

| Table | Purpose |
|-------|---------|
| `gl_sub_ledger_mapping` | GL account ↔ sub-ledger account relationships |

### Hash Snapshots

| Table | Purpose |
|-------|---------|
| `hash_snapshot` | Verification snapshots for fast reconciliation |

## Schema Configuration

### Custom Schema Name

```ts
const summa = createSumma({
  database: adapter,
  schema: "ledger", // Tables will be created in "ledger" schema
});
```

This creates all tables under `ledger.*` (e.g., `ledger.account`, `ledger.transfer`). Useful for multi-tenant deployments or keeping Summa isolated from your application tables.

### Public Schema

```ts
const summa = createSumma({
  database: adapter,
  schema: "public", // Tables in default schema
});
```

### Multiple Instances

You can run multiple Summa instances in the same database with different schema names:

```ts
const usdLedger = createSumma({ database: adapter, schema: "ledger_usd", currency: "USD" });
const eurLedger = createSumma({ database: adapter, schema: "ledger_eur", currency: "EUR" });
```

## Migrations

### Direct Push

```bash
npx summa migrate push
```

Compares the current database state against Summa's schema definitions and applies changes. Recommended for getting started.

### ORM Migrations

Generate schema files for your ORM, then use its migration tooling:

```bash
# Drizzle
npx summa generate --adapter drizzle --out src/db/summa-schema.ts

# Prisma
npx summa generate --adapter prisma --out prisma/summa-schema.prisma

# Kysely
npx summa generate --adapter kysely --out src/db/summa-schema.ts
```

See [Drizzle Adapter](/docs/adapters/drizzle#migrations) for full migration workflow.

### Migration Commands

| Command | Description |
|---------|-------------|
| `summa migrate push` | Apply schema directly to database |
| `summa migrate generate` | Generate versioned SQL migration files |
| `summa migrate status` | Show pending schema changes |
| `summa migrate list` | Show applied migration history |
| `summa migrate rollback` | Revert last N migrations (wrapped in a transaction for atomicity) |

## Entity Relationship

```
entry (source of truth — accounting journal + tamper-proof event log)
    ↓ records mutations to
account (unified — user + system accounts, mutable balance with checksum)
    ↑                     ↑
    │              entry → transfer (status mutable, history in entity_status_log)
    │                          ↑
    ├── account_limit          ├── idempotency_key
    │                          └── outbox
    │
block_checkpoint → merkle_node (Merkle tree)
block_checkpoint ← verifies → entry (via sequence_number range)
entity_status_log ← tracks → transfers + plugin entities
worker_lease ← coordinates → background workers
```

## Table Count

| Category | Tables |
|----------|:------:|
| Core | 10 |
| Hot Accounts plugin | 1 |
| Outbox plugin | 1 |
| Velocity Limits plugin | 1 |
| Scheduled Transactions plugin | 1 |
| Reconciliation plugin | 2 |
| Snapshots plugin | 1 |
| DLQ Manager plugin | 1 |
| Audit Log plugin | 1 |
| Accrual Accounting plugin | 2 |
| FX Engine plugin | 3 |
| Approval Workflow plugin | 2 |
| Batch Import plugin | 2 |
| GL Sub-Ledger plugin | 1 |
| Hash Snapshots plugin | 1 |
| **Total** | **30** |
