---
title: Transactions
description: Transfer, credit, debit, refund, journal entries, corrections, and multi-destination payments.
icon: ArrowsRightLeft
---

## Overview

Transactions are the core operation in Summa. Every transaction uses **double-entry bookkeeping** — for every debit, there is an equal and opposite credit. The sum of all entries in the ledger is always zero.

## Transaction Object

Every transaction returns:

```ts
interface LedgerTransaction {
  id: string;                       // UUID
  reference: string;                // Your business reference
  type: TransactionType;            // "credit" | "debit" | "transfer" | "journal" | "correction" | "adjustment"
  status: TransactionStatus;        // "posted" | "reversed" | etc.
  amount: number;                   // Smallest currency unit (cents/paise)
  amountDecimal: string;            // Display format: "254.90"
  currency: string;
  description: string;
  sourceAccountId: string | null;
  destinationAccountId: string | null;
  correlationId: string;            // Groups related events
  isReversal: boolean;
  parentId: string | null;          // Parent transaction (for refunds)
  metadata: Record<string, unknown>;
  createdAt: string;
  postedAt: string | null;
}
```

**Transaction types:** `"credit"` | `"debit"` | `"transfer"` | `"journal"` | `"correction"` | `"adjustment"`

**Transaction statuses:** `"pending"` | `"inflight"` | `"posted"` | `"expired"` | `"voided"` | `"reversed"`

## Basic Operations

<Tabs items={["Transfer", "Credit", "Debit"]}>
<Tab value="Transfer">
Move funds between two user accounts:

```ts
const txn = await summa.transactions.transfer({
  sourceHolderId: "user_123",
  destinationHolderId: "merchant_1",
  amount: 50_00,
  reference: "order_abc",
  description: "Payment for Order #ABC",
  category: "payment",
  metadata: { orderId: "abc" },
  idempotencyKey: "pay_abc_v1",
});
```

Creates two entry records: a DEBIT on the source account and a CREDIT on the destination.

</Tab>
<Tab value="Credit">

Add funds to a user account. Funds come from a system account (default: `@World`):

```ts
const txn = await summa.transactions.credit({
  holderId: "user_123",
  amount: 100_00,
  reference: "deposit_001",
  description: "Bank transfer deposit",
  sourceSystemAccount: "@Revenue",  // Optional — defaults to @World
  idempotencyKey: "dep_001",
});
```

</Tab>
<Tab value="Debit">

Remove funds from a user account. Funds go to a system account (default: `@World`):

```ts
const txn = await summa.transactions.debit({
  holderId: "user_123",
  amount: 5_00,
  reference: "fee_001",
  description: "Monthly platform fee",
  destinationSystemAccount: "@Fees",  // Optional — defaults to @World
  allowOverdraft: false,
  idempotencyKey: "fee_001",
});
```

</Tab>
</Tabs>

### Refunds

Refund a posted transaction to reverse the balance changes:

<Tabs items={["Full refund", "Partial refund"]}>
<Tab value="Full refund">

```ts
const refund = await summa.transactions.refund({
  transactionId: txn.id,
  reason: "Customer refund — item not received",
});
```

</Tab>
<Tab value="Partial refund">

```ts
const partial = await summa.transactions.refund({
  transactionId: txn.id,
  reason: "Partial refund — 1 of 3 items returned",
  amount: 25_00,
  idempotencyKey: "refund_abc_partial",
});
```

</Tab>
</Tabs>

Refunds create a new transaction with `isReversal: true` and `parentId` pointing to the original.

## Multi-Party Operations

### Multi-Destination Transfer

Split a payment across multiple recipients in a single atomic transaction:

```ts
const txn = await summa.transactions.multiTransfer({
  sourceHolderId: "user_123",
  amount: 100_00,
  destinations: [
    { holderId: "merchant_1", amount: 90_00 },
    { holderId: "affiliate_1", amount: 5_00 },
    { systemAccount: "@Fees", amount: 5_00 },
  ],
  reference: "marketplace_pay_001",
  description: "Marketplace order payout",
});
```

Each destination can be a `holderId` (user account) or `systemAccount` (platform account). If one destination omits `amount`, it receives the remainder.

### Journal Entries

N-leg journal entries support arbitrary combinations of debits and credits in a single atomic transaction. Use this for complex multi-party entries like payroll, revenue splits, or accruals.

```ts
const txn = await summa.transactions.journal({
  entries: [
    { holderId: "employee_1", amount: 500_000, direction: "credit", description: "Salary" },
    { holderId: "employee_2", amount: 450_000, direction: "credit", description: "Salary" },
    { systemAccount: "@Payroll", amount: 950_000, direction: "debit", description: "Payroll expense" },
  ],
  reference: "payroll-jan-2026",
  description: "January payroll run",
  idempotencyKey: "payroll-jan-2026",
});
```

Each entry leg specifies either a `holderId` (user account) or `systemAccount` (platform account), along with an `amount` and `direction`.

<Callout type="warn" title="Balanced entries required">
  The sum of all debit amounts must equal the sum of all credit amounts. Unbalanced entries are rejected with `INVALID_ARGUMENT`.
</Callout>

#### JournalEntryLeg

<TypeTable
  type={{
    holderId: { type: "string", description: "Holder ID of a user account (mutually exclusive with systemAccount)." },
    systemAccount: { type: "string", description: "System account identifier, e.g. @Fees (mutually exclusive with holderId)." },
    amount: { type: "number", description: "Amount in smallest currency units.", required: true },
    direction: { type: '"debit" | "credit"', description: "Entry direction.", required: true },
    description: { type: "string", description: "Per-leg description." },
  }}
/>

## Corrections & Adjustments

### Corrections

Atomic correction: reverse the original transaction and post new correcting entries in a single database transaction.

```ts
const { reversal, correction } = await summa.transactions.correct({
  transactionId: originalTxn.id,
  correctionEntries: [
    { holderId: "user_123", amount: 45_00, direction: "debit" },
    { holderId: "merchant_1", amount: 45_00, direction: "credit" },
  ],
  reason: "Incorrect amount — should have been $45.00",
  reference: "correction-001",
  idempotencyKey: "correct-order-abc",
});
```

The `reversal` is the auto-generated reversal of the original, and `correction` is the new correcting entry. Both are linked via `correlationId`.

<Callout type="info" title="Cannot correct reversed transactions">
  Only transactions with status `"posted"` can be corrected. Already-reversed or voided transactions will throw an error.
</Callout>

### Adjustments

Typed adjustment entries for accounting operations like accruals, depreciation, reclassifications, and manual corrections.

```ts
const txn = await summa.transactions.adjust({
  entries: [
    { holderId: "prepaid_insurance", amount: 1_000_00, direction: "credit" },
    { holderId: "insurance_expense", amount: 1_000_00, direction: "debit" },
  ],
  reference: "adj-feb-2026",
  adjustmentType: "accrual",
  description: "Monthly insurance accrual",
  idempotencyKey: "adj-insurance-feb",
});
```

| Adjustment Type | Use Case |
|----------------|----------|
| `accrual` | Recognize earned revenue or incurred expenses |
| `depreciation` | Record periodic asset depreciation |
| `correction` | Fix posting errors |
| `reclassification` | Move amounts between account categories |

## Cross-Currency Transfers

If the [FX Engine plugin](/docs/plugins/fx-engine) is registered, cross-currency transfers automatically resolve exchange rates from your configured rate provider:

```ts
const txn = await summa.transactions.transfer({
  sourceHolderId: "user_usd",
  destinationHolderId: "user_eur",
  amount: 100_00,              // $100 debited from source
  reference: "fx-transfer-001",
});
// Source debited $100.00, destination credited €92.00 — rate auto-resolved
```

You can override auto-resolution by providing `exchangeRate` explicitly:

```ts
const txn = await summa.transactions.transfer({
  sourceHolderId: "user_usd",
  destinationHolderId: "user_eur",
  amount: 100_00,              // $100 debited from source
  reference: "fx-transfer-001",
  exchangeRate: 920_000,       // 0.92 EUR/USD (6 decimal precision as integer)
});
// Source debited $100.00, destination credited €92.00
```

Without the FX Engine plugin, `exchangeRate` is required for cross-currency transfers.

<Callout type="info" title="Exchange rate format">
  Exchange rates are integers with 6 decimal precision. A rate of `1.000000` is stored as `1_000_000`. For example, `0.92 EUR/USD` is `920_000`.
</Callout>

## Querying Transactions

### Listing Transactions

```ts
const result = await summa.transactions.list({
  holderId: "user_123",
  page: 1,
  perPage: 20,
  type: "transfer",
  status: "posted",
  category: "payment",
  dateFrom: "2025-01-01",
  dateTo: "2025-01-31",
  amountMin: 10_00,
  amountMax: 500_00,
  sortBy: "createdAt",
});

// result.transactions — LedgerTransaction[]
// result.hasMore      — boolean
// result.total        — number (optional)
```

### Getting a Transaction

```ts
const txn = await summa.transactions.get(transactionId);
```

### Categories

Categories let you segment transactions for reporting and velocity limits:

```ts
// Tag transactions with a category
await summa.transactions.transfer({
  sourceHolderId: "user_123",
  destinationHolderId: "merchant_1",
  amount: 50_00,
  reference: "order_001",
  category: "marketplace",
});

// Set velocity limits per category
await summa.limits.set({
  holderId: "user_123",
  limitType: "daily",
  maxAmount: 500_00,
  category: "marketplace",  // Only applies to marketplace transactions
});
```

## Idempotency

Use idempotency keys to safely retry operations across network failures:

```ts
const txn = await summa.transactions.transfer({
  sourceHolderId: "user_123",
  destinationHolderId: "merchant_1",
  amount: 50_00,
  reference: "order_abc",
  idempotencyKey: "pay_order_abc_v1",
});
```

<Callout type="info" title="How idempotency works">
  If you retry with the same `idempotencyKey`, Summa returns the original result without executing the transaction again. Keys expire after `advanced.idempotencyTTL` (default: 24 hours).
</Callout>

<Callout type="warn" title="Duplicate key with different params">
  A duplicate key with *different* parameters throws a `DUPLICATE` error (HTTP 409).
</Callout>
