---
title: Summa
description: Event-sourced double-entry financial ledger for TypeScript.
icon: BookOpen
---

import { Cards, Card } from "fumadocs-ui/components/card";

## What is Summa?

Summa is an **event-sourced double-entry financial ledger** for TypeScript. It provides a complete, production-grade foundation for building fintech applications, marketplaces, wallets, and any system that needs to track money movement with absolute accuracy.

Every mutation in Summa produces an immutable event with a **SHA-256 hash chain** for tamper detection — the same cryptographic verification used in blockchain systems, but without the overhead.

## Why Summa?

| Challenge | How Summa solves it |
|-----------|-------------------|
| **Double-spending** | Pessimistic locks + balance checks in a single database transaction |
| **Lost transactions** | Event sourcing with append-only log — nothing is ever deleted |
| **Audit requirements** | Cryptographic hash chain verifies no event was modified or removed |
| **High-traffic accounts** | Hot account pattern with optimistic concurrency (no row-level lock contention) |
| **Network retries** | Built-in idempotency keys prevent duplicate transactions |
| **Partial failures** | Two-phase holds: reserve first, commit or void later |
| **Data inconsistency** | Automated reconciliation compares balances against entry records |

## Built Like a Steel Vault

Summa is designed with the same invariants that banks and payment processors rely on. Every layer enforces correctness — not by convention, but by constraint.

<Accordions>
<Accordion title="Atomic Double-Entry">
Every transaction produces exactly balanced DEBIT and CREDIT entries inside a single database transaction. If anything fails, nothing is written. The fundamental accounting equation holds at all times: the sum of all entries across the entire ledger is always exactly zero.
</Accordion>
<Accordion title="Immutable Event Log">
Every state change (account created, transaction posted, hold committed) is recorded as an immutable event. Events are never updated or deleted — only appended. This gives you a complete, tamper-proof timeline of every financial operation.
</Accordion>
<Accordion title="Cryptographic Hash Chain">
Each event is linked to its predecessor via SHA-256 hashing, forming a verifiable chain per aggregate. If a single event is modified, reordered, or deleted, the chain breaks — and Summa's `verify` command detects it instantly. The same integrity guarantee as a blockchain, without the consensus overhead.
</Accordion>
<Accordion title="Pessimistic Locking">
Balance checks and mutations happen under PostgreSQL `SELECT ... FOR UPDATE` locks within advisory lock scopes. No race condition can cause a balance to go negative (unless explicitly allowed with `allowOverdraft`). Two concurrent transfers from the same account will never double-spend.
</Accordion>
<Accordion title="Idempotency by Default">
Every mutation accepts an idempotency key. Retrying the same request with the same key and parameters returns the original result. Retrying with different parameters returns a `DUPLICATE_IDEMPOTENCY_KEY` error. Safe retries across network failures, load balancer timeouts, and client crashes.
</Accordion>
<Accordion title="Automated Reconciliation">
The reconciliation plugin independently recalculates every account balance from raw entry records and compares against stored balances. Any discrepancy is flagged immediately. Run it on a schedule, or trigger it manually — it's your financial safety net.
</Accordion>
</Accordions>

## Security

Financial systems are high-value targets. Summa doesn't bolt security on as an afterthought — it's built into the architecture at every layer.

### Protect the Money

<Cards>
  <Card title="No Double-Spending">
    Every balance check and debit runs inside a database row lock. Two concurrent transfers from the same account queue safely — it's structurally impossible to spend more than what's available.
  </Card>
  <Card title="Safe Retries">
    Submitting the same payment twice returns the original result. Built-in idempotency keys ensure network retries and client crashes never cause duplicate charges.
  </Card>
  <Card title="Instant Account Freeze">
    Any account can be frozen in one call — all transactions are blocked immediately. The reason, actor, and timestamp are recorded immutably.
  </Card>
  <Card title="Spending Limits">
    Cap how much any account can spend per transaction, per day, or per month. Limits are enforced inside the same atomic lock as the transaction itself.
  </Card>
</Cards>

### Prove What Happened

<Cards>
  <Card title="Tamper-Evident Ledger">
    Every event is sealed into a cryptographic hash chain. If anyone alters a single record in the database, verification instantly detects the break.
  </Card>
  <Card title="Full Audit Trail">
    Every operation is permanently logged with who did it, what they did, and when. Actor identity flows automatically from HTTP headers into audit entries.
  </Card>
  <Card title="HMAC-Secured Hashes">
    One config key upgrades every hash from SHA-256 to HMAC-SHA256 — so even full database access cannot forge a valid audit trail.
  </Card>
  <Card title="Automated Reconciliation">
    A background worker independently recalculates every balance from raw entries and flags any discrepancy. Your financial safety net runs on autopilot.
  </Card>
</Cards>

### Lock Down the API

<Cards>
  <Card title="Rate Limiting">
    Built-in throttling with memory, database, or Redis backends. Four presets from lenient (500/min) to burst protection (10/sec). Responses include standard rate-limit headers.
  </Card>
  <Card title="Security Headers">
    Every response includes CSP, X-Frame-Options, X-Content-Type-Options, and Referrer-Policy headers. No configuration needed — secure by default.
  </Card>
  <Card title="CSRF Protection">
    Mutating requests from browsers are validated against a trusted origin list. Server-to-server calls pass through without friction.
  </Card>
  <Card title="Webhook Signatures">
    Outgoing webhooks are signed with HMAC-SHA256. A 5-minute replay window rejects stale payloads, even if the signature is valid.
  </Card>
</Cards>

### Protect Sensitive Data

<Cards>
  <Card title="PII Redaction">
    Emails, phone numbers, passwords, and tokens are automatically scrubbed from all log output before reaching your log aggregation system.
  </Card>
  <Card title="Parameterized Queries">
    No user input ever touches raw SQL. Every database query uses parameterized placeholders, making injection attacks structurally impossible.
  </Card>
  <Card title="Data Retention Policies">
    Sensitive operational data is automatically purged on a schedule. You control exactly how long each data type is retained — from 24 hours to 7 years.
  </Card>
  <Card title="Configurable Redact Keys">
    The default redaction set covers common PII fields. Add your own keys (credit card numbers, tax IDs, bank accounts) with a single config option.
  </Card>
</Cards>

## Core Architecture

| Layer | Components |
|-------|-----------|
| **Your Application** | Your API routes, workers, cron jobs |
| **Summa API** | `accounts` · `transactions` · `holds` · `events` · `limits` · `workers` |
| **Plugin System** | `audit` · `reconciliation` · `snapshots` · `velocity` · `holdExpiry` · `freezeExpiry` · `outbox` · `dlq` · `hot` · `scheduled` · `mnt` · `admin` · `openApi` · `observability` · `fx` · `accrual` · `reporting` · `retention` · `i18n` · `mcp` · `statements` · `periodClose` · `glSubLedger` · `approvalWorkflow` · `batchImport` |
| **Database Adapters** | Drizzle · Prisma · Kysely · Memory |

## Key Features

<Cards>
  <Card title="Double-Entry Bookkeeping" href="/docs/transactions">
    Every transaction creates balanced DEBIT and CREDIT entries. The sum of all entries is always zero.
  </Card>
  <Card title="Event Sourcing" href="/docs/events">
    Immutable append-only event log with SHA-256 hash chain verification. Full audit trail for every mutation.
  </Card>
  <Card title="Two-Phase Holds" href="/docs/holds">
    Reserve funds before settlement. Supports partial capture, void, expiry, and multi-destination splits.
  </Card>
  <Card title="25 Built-in Plugins" href="/docs/plugins">
    Audit log, reconciliation, snapshots, velocity limits, FX engine, accrual accounting, financial reporting, data retention, observability, i18n, MCP, and more.
  </Card>
  <Card title="Idempotency" href="/docs/transactions#idempotency">
    Built-in idempotency key support. Safe retries with no double-posting, even under network failures.
  </Card>
  <Card title="Multi-Destination Transfers" href="/docs/transactions#operations">
    Split payments across multiple recipients in a single atomic transaction.
  </Card>
  <Card title="Velocity Limits" href="/docs/plugins/velocity-limits">
    Configurable per-transaction, daily, and monthly limits with category-based segmentation.
  </Card>
  <Card title="4 Database Adapters" href="/docs/adapters/drizzle">
    Drizzle ORM, Prisma, Kysely, or in-memory for testing. Bring your own ORM.
  </Card>
</Cards>

## Quick Example

```bash
pnpm add summa @summa/core @summa/drizzle-adapter drizzle-orm
```

```ts title="src/summa.ts"
import { createSumma } from "summa";
import { drizzleAdapter } from "@summa/drizzle-adapter";
import { auditLog, reconciliation, velocityLimits } from "summa/plugins";
import { drizzle } from "drizzle-orm/node-postgres";

const db = drizzle(process.env.DATABASE_URL!);

export const summa = createSumma({
  database: drizzleAdapter(db),
  currency: "USD",
  plugins: [auditLog(), reconciliation(), velocityLimits()],
});
```

```ts
// Create accounts
await summa.accounts.create({
  holderId: "user_123", holderType: "individual", currency: "USD",
});
await summa.accounts.create({
  holderId: "merchant_1", holderType: "organization", currency: "USD",
});

// Credit $100 (from system → user)
await summa.transactions.credit({
  holderId: "user_123",
  amount: 100_00,
  reference: "deposit-001",
});

// Transfer $50 (user → merchant)
await summa.transactions.transfer({
  sourceHolderId: "user_123",
  destinationHolderId: "merchant_1",
  amount: 50_00,
  reference: "order-001",
});

// Check balance
const balance = await summa.accounts.getBalance("user_123");
// => { balance: 5000, availableBalance: 5000, currency: "USD", ... }
```

## Packages

<Files>
  <File name="summa" />
  <File name="@summa/core" />
  <File name="@summa/cli" />
  <File name="@summa/drizzle-adapter" />
  <File name="@summa/prisma-adapter" />
  <File name="@summa/kysely-adapter" />
  <File name="@summa/memory-adapter" />
  <File name="@summa/client" />
  <File name="@summa/redis-storage" />
  <File name="@summa/telemetry" />
  <File name="@summa/test-utils" />
</Files>

| Package | Description |
|---------|-------------|
| `summa` | Main ledger library with all managers and plugins |
| `@summa/core` | Core types, adapter interface, plugin interface, SQL dialects (PostgreSQL, MySQL, SQLite) |
| `@summa/cli` | CLI for migrations, integrity checks, diagnostics, auto-install, and client codegen |
| `@summa/drizzle-adapter` | Drizzle ORM adapter |
| `@summa/prisma-adapter` | Prisma adapter |
| `@summa/kysely-adapter` | Kysely adapter |
| `@summa/memory-adapter` | In-memory adapter for testing |
| `@summa/client` | Type-safe HTTP client SDK with React, Vue, and Svelte bindings |
| `@summa/redis-storage` | Redis-backed secondary storage for rate limiting and caching |
| `@summa/telemetry` | CLI usage analytics + optional OpenTelemetry tracing integration |
| `@summa/test-utils` | Test assertions, structured test suite runner, balance and hash chain verification |

## Next Steps

<Cards>
  <Card title="Getting Started" href="/docs/getting-started">
    Install, configure, and run your first transaction.
  </Card>
  <Card title="Configuration" href="/docs/configuration">
    All options, system accounts, advanced settings.
  </Card>
  <Card title="Accounts" href="/docs/accounts">
    Create, freeze, close, overdraft.
  </Card>
  <Card title="Transactions" href="/docs/transactions">
    Transfer, credit, debit, refund, multi-destination.
  </Card>
  <Card title="Holds" href="/docs/holds">
    Two-phase commits with partial capture.
  </Card>
  <Card title="Events" href="/docs/events">
    Event sourcing and hash chain integrity.
  </Card>
  <Card title="Plugins" href="/docs/plugins">
    Extend with 25 built-in plugins.
  </Card>
  <Card title="Client SDK" href="/docs/client-sdk">
    Type-safe HTTP client for service-to-service calls.
  </Card>
  <Card title="CLI Reference" href="/docs/cli">
    Migrations, integrity checks, diagnostics.
  </Card>
</Cards>
