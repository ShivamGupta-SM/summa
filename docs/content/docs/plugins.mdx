---
title: Plugins
description: Extend Summa with reconciliation, snapshots, velocity limits, and more.
icon: PuzzlePiece
---

## Overview

Summa's plugin system extends the core ledger with additional functionality through **lifecycle hooks**, **background workers**, and **database schema extensions**. Plugins are composable — enable only what you need.

```ts
import {
  auditLog,
  reconciliation,
  snapshots,
  velocityLimits,
  holdExpiry,
  outbox,
  dlqManager,
  hotAccounts,
  scheduledTransactions,
  maintenance,
  admin,
  openApi,
  observability,
} from "summa/plugins";

const summa = createSumma({
  database: adapter,
  currency: "USD",
  plugins: [
    auditLog(),
    reconciliation(),
    snapshots(),
    velocityLimits(),
    holdExpiry(),
    outbox({ publisher: myPublisher }),
    dlqManager(),
    hotAccounts(),
    scheduledTransactions(),
    maintenance(),
    admin({ authorize: (req) => req.headers?.["x-admin-key"] === process.env.ADMIN_KEY }),
    openApi(),
    observability(),
  ],
});
```

## Available Plugins

| Plugin | Category | Background Worker | Description |
|--------|----------|:-:|-------------|
| [`auditLog`](/docs/plugins/audit-log) | Compliance | Yes | Immutable audit trail for all ledger operations |
| [`reconciliation`](/docs/plugins/reconciliation) | Integrity | Yes | Automated balance reconciliation with 5-step verification |
| [`snapshots`](/docs/plugins/snapshots) | Reporting | Yes | Point-in-time balance snapshots for historical queries |
| [`velocityLimits`](/docs/plugins/velocity-limits) | Security | Yes | Per-transaction, daily, and monthly amount limits |
| [`holdExpiry`](/docs/plugins/hold-expiry) | Automation | Yes | Automatic void of expired holds |
| [`outbox`](/docs/plugins/outbox) | Integration | Yes | Transactional outbox for reliable event publishing |
| [`dlqManager`](/docs/plugins/dlq-manager) | Operations | Yes | Dead letter queue for failed event processing |
| [`hotAccounts`](/docs/plugins/hot-accounts) | Performance | Yes | Optimistic concurrency for high-traffic accounts |
| [`scheduledTransactions`](/docs/plugins/scheduled-transactions) | Automation | Yes | Future and recurring transaction scheduling |
| [`maintenance`](/docs/plugins/maintenance) | Operations | Yes | Automated cleanup of expired data |
| [`admin`](/docs/plugins/admin) | Management | No | Elevated admin endpoints with authorization and dashboard stats |
| [`openApi`](/docs/plugins/open-api) | Documentation | No | Auto-generated OpenAPI 3.1 specification |
| [`observability`](/docs/plugins/observability) | Monitoring | No | Distributed tracing and Prometheus metrics via `/metrics` endpoint |

## Plugin Architecture

Every plugin implements the `SummaPlugin` interface:

```ts
interface SummaPlugin {
  id: string;                    // Unique identifier
  dependencies?: string[];       // Plugin IDs that must load first
  init?: (ctx) => Promise<void>; // Called on startup

  // HTTP endpoints contributed by the plugin
  endpoints?: PluginEndpoint[];

  // Lifecycle hooks
  hooks?: {
    beforeTransaction?: (params) => Promise<void>;
    afterTransaction?: (params) => Promise<void>;
    beforeAccountCreate?: (params) => Promise<void>;
    afterAccountCreate?: (params) => Promise<void>;
    beforeHoldCreate?: (params) => Promise<void>;
    afterHoldCommit?: (params) => Promise<void>;
  };

  // HTTP-level request/response interceptors
  onRequest?: (req) => req | response;  // Return response to short-circuit
  onResponse?: (req, res) => res;       // Modify response before sending

  // Background workers
  workers?: SummaWorkerDefinition[];

  // Database tables (auto-created by migrate push)
  schema?: Record<string, TableDefinition>;

  // Custom error codes
  $ERROR_CODES?: Record<string, RawErrorCode>;

  // Type inference for TypeScript
  $Infer?: Record<string, unknown>;
}
```

### Lifecycle Hooks

Hooks run **synchronously within the database transaction** — if a `beforeTransaction` hook throws, the entire transaction is rolled back.

| Hook | When it runs | Can cancel? |
|------|-------------|:-:|
| `beforeTransaction` | Before any credit/debit/transfer | Yes — throw to reject |
| `afterTransaction` | After transaction is posted | No |
| `beforeAccountCreate` | Before account creation | Yes |
| `afterAccountCreate` | After account is created | No |
| `beforeHoldCreate` | Before hold creation | Yes |
| `afterHoldCommit` | After hold is committed | No |

Example — the velocity limits plugin uses `beforeTransaction` to check limits:

```ts
hooks: {
  beforeTransaction: async ({ type, amount, holderId, category, ctx }) => {
    const result = await checkLimits(ctx, holderId, amount, category);
    if (!result.allowed) {
      throw new SummaError("LIMIT_EXCEEDED", result.message);
    }
  },
}
```

### Plugin Dependencies

Plugins can declare dependencies on other plugins. Summa validates that all required plugins are registered and sorts them topologically at startup.

```ts
{
  id: "my-plugin",
  dependencies: ["audit-log", "reconciliation"],
  // ...
}
```

If a required plugin is missing, `createSumma()` throws immediately:

```
Plugin "my-plugin" requires plugin "audit-log" which is not registered
```

### Request/Response Interceptors

Plugins can intercept HTTP requests and responses at the handler level — before and after route matching. This is how the `observability` plugin adds tracing and metrics.

```ts
{
  id: "my-auth-plugin",
  onRequest: (req) => {
    if (!req.headers?.["authorization"]) {
      return { status: 401, body: { error: "Unauthorized" } };
    }
    return req; // Continue to route handler
  },
  onResponse: (req, res) => {
    return { ...res, headers: { ...res.headers, "X-Custom": "value" } };
  },
}
```

- `onRequest` runs **after** CSRF/rate-limiting, **before** route matching. Return a response object to short-circuit.
- `onResponse` runs **after** the route handler, in **reverse plugin order** (middleware stack unwinding).

### Background Workers

Workers run on configurable intervals with **distributed lease** support — in a multi-instance deployment, only one instance runs each worker.

```ts
interface SummaWorkerDefinition {
  id: string;              // Unique worker ID
  handler: (ctx) => Promise<void>;
  interval: string;        // "5s" | "1m" | "30m" | "1h" | "1d"
  leaseRequired?: boolean; // Prevents duplicate runs in cluster
}
```

Start all plugin workers:

```ts
await summa.workers.start();

// Graceful shutdown
process.on("SIGTERM", async () => {
  await summa.workers.stop();
});
```

Worker intervals support `"5s"`, `"1m"`, `"30m"`, `"1h"`, `"1d"` format. A ±25% jitter is applied to prevent thundering herd effects. Lease duration is `2x` the worker interval.

### Type Inference

Plugins can extend the Summa instance with type-safe properties via `$Infer`:

```ts
// Access plugin-provided types
type AuditEntry = typeof summa.$Infer.AuditLogEntry;
type OutboxStats = typeof summa.$Infer.OutboxStats;
type HotStats = typeof summa.$Infer.HotAccountStats;
type DlqStats = typeof summa.$Infer.DlqStats;
type FailedEvent = typeof summa.$Infer.FailedEvent;
```

## Recommended Plugin Combinations

### Minimum Production Setup

```ts
plugins: [
  auditLog(),         // Compliance and debugging
  reconciliation(),   // Data integrity verification
  maintenance(),      // Cleanup expired keys and events
]
```

### Full Production Setup

```ts
plugins: [
  auditLog(),
  reconciliation(),
  snapshots(),
  velocityLimits(),
  holdExpiry(),
  outbox({ publisher: myPublisher }),
  dlqManager(),
  hotAccounts(),
  maintenance(),
  observability(),
  admin({ authorize: checkAdminAuth }),
  openApi(),
]
```

### Testing / Development

```ts
plugins: []  // No plugins needed for basic testing
```

### Plugin Endpoints

Plugins can contribute HTTP endpoints that are automatically routed through the API handler:

```ts
interface PluginEndpoint {
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  path: string;
  handler: (req: PluginApiRequest, ctx: SummaContext) => Promise<PluginApiResponse>;
}
```

For example, the `admin` plugin adds 13 management endpoints, and the `openApi` plugin serves the generated spec at `/openapi.json`. See [HTTP API](/docs/api-reference#plugin-endpoints) for the full list.

See individual plugin pages for configuration options and detailed documentation.
