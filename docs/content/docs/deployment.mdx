---
title: Deployment
description: Production deployment patterns, monitoring, and operational guidelines.
icon: CloudArrowUp
---

## Overview

This guide covers production deployment patterns for Summa, including database setup, worker management, observability, graceful shutdown, and security hardening.

## Database Setup

### Connection Pooling

Use `RECOMMENDED_POOL_CONFIG` and `createPooledAdapter()` for production-ready pool management with monitoring and graceful shutdown:

```ts
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";
import {
  createPooledAdapter,
  RECOMMENDED_POOL_CONFIG,
} from "@summa-ledger/drizzle-adapter";

const pool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_URL,
});

const db = drizzle(pool);
const { adapter, close, stats } = createPooledAdapter({ pool, drizzle: db });

// Monitor pool health
setInterval(() => {
  const s = stats();
  logger.info("Pool stats", s);
  if (s.waitingCount > 0) {
    logger.warn("Clients waiting for connections", { waiting: s.waitingCount });
  }
}, 60_000);
```

See [Drizzle Adapter — Connection Pooling](/docs/adapters/drizzle#connection-pooling) for full configuration reference.

**Pool sizing guidelines:**

| Workload | `max` connections | Notes |
|----------|:-:|-------|
| Light (< 100 txn/min) | 5–10 | Default for small services |
| Medium (100–1000 txn/min) | 10–20 | Most production workloads |
| Heavy (1000+ txn/min) | 20–50 | Enable hot accounts plugin |

### Read Replicas

For read-heavy workloads, use `createReadReplicaAdapter()` to offload reads to PostgreSQL replicas:

```ts
import { createReadReplicaAdapter } from "@summa-ledger/core/db";
import { drizzleAdapter } from "@summa-ledger/drizzle-adapter";

const primary = drizzleAdapter(drizzle(primaryPool));
const replica = drizzleAdapter(drizzle(replicaPool));

const adapter = createReadReplicaAdapter({
  primary,
  replicas: [replica],
  strategy: "round-robin",
});
```

Read operations (`findOne`, `findMany`, `count`, SELECT queries) go to replicas. Writes, transactions, and `FOR UPDATE` queries always go to the primary. See [Drizzle Adapter — Read Replicas](/docs/adapters/drizzle#read-replicas) for routing details.

### Redis for Distributed State

For multi-instance deployments, configure `@summa-ledger/redis-storage` as secondary storage. This enables distributed rate limiting, shared idempotency caching, and plugin state across instances:

```bash
pnpm add @summa-ledger/redis-storage ioredis
```

```ts
import Redis from "ioredis";
import { createRedisStorage } from "@summa-ledger/redis-storage";

const redis = new Redis(process.env.REDIS_URL!);
const { storage, disconnect } = createRedisStorage({ client: redis });

const summa = createSumma({
  database: adapter,
  secondaryStorage: storage,
});
```

See [Configuration — secondaryStorage](/docs/configuration#secondarystorage) for setup options.

### Schema & Migrations

#### Schema Namespace

By default, Summa creates all tables in the `"summa"` PostgreSQL schema, keeping them isolated from your application's `public` schema. You can verify this after migration:

```sql
\dt summa.*          -- List all Summa tables
\dt public.*         -- Your app tables, clean of ledger tables
```

To use a different schema, set `schema` in your config. See [Configuration — schema](/docs/configuration#schema).

#### Running Migrations

Run migrations during deployment (not at application startup):

```bash
# Preview changes
npx summa migrate status --url "$DATABASE_URL"

# Apply changes
npx summa migrate push --url "$DATABASE_URL" --yes
```

For zero-downtime deployments, use your ORM's migration tooling:

```bash
npx summa generate --adapter drizzle --out src/db/schema.ts --yes
npx drizzle-kit push
```

## Worker Management

### Starting Workers

Workers should start after your HTTP server is ready:

```ts
const server = app.listen(3000, async () => {
  console.log("Server ready on :3000");
  await summa.workers.start();
});
```

### Graceful Shutdown

Always stop workers, close Redis, and drain the connection pool before process exit:

```ts
async function shutdown() {
  console.log("Shutting down...");

  // 1. Stop background workers (awaits running workers up to 10s)
  await summa.workers.stop();

  // 2. Disconnect Redis (if using @summa-ledger/redis-storage)
  await disconnect();

  // 3. Drain the connection pool
  await close();

  server.close();
  process.exit(0);
}

process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
```

### Multi-Instance Deployment

Workers use **distributed leases** via advisory locks. In a multi-instance deployment (Kubernetes, ECS, etc.), only one instance runs each worker. No additional configuration needed.

## Observability

### Structured Logging

Use the built-in JSON logger for log aggregation:

```ts
import { createJsonLogger } from "@summa-ledger/core/logger";

const summa = createSumma({
  database: adapter,
  logger: createJsonLogger({ level: "info", service: "ledger" }),
});
```

Output (one JSON line per log entry):
```json
{"timestamp":"2026-02-21T10:30:00.000Z","level":"info","service":"ledger","message":"Transaction posted"}
```

### Prometheus Metrics

Enable the observability plugin for request metrics:

```ts
import { observability } from "@summa-ledger/summa/plugins";

plugins: [
  observability({ serviceName: "ledger" }),
]
```

Scrape `GET /api/ledger/metrics` with Prometheus. See [Observability Plugin](/docs/plugins/observability) for available metrics.

### Request Tracing

Every API response includes an `X-Request-Id` header. Forward the `x-request-id` header from your API gateway for end-to-end trace correlation. The observability plugin also propagates `traceparent` headers for distributed tracing.

### OpenTelemetry Integration

For production-grade distributed tracing, use the `@summa-ledger/telemetry` package which provides optional OpenTelemetry integration:

```bash
pnpm add @summa-ledger/telemetry @opentelemetry/api
```

```ts
import { createOtelLogger, createRequestTracer } from "@summa-ledger/telemetry";
import { createConsoleLogger } from "@summa-ledger/core/logger";

// Wrap the logger with OTEL span creation for warn/error entries
const logger = createOtelLogger(createConsoleLogger(), {
  serviceName: "summa-ledger",
});

// Create a request tracer for HTTP spans
const tracer = createRequestTracer({ serviceName: "summa-ledger" });
```

The OTEL integration is opt-in — if `@opentelemetry/api` is not installed, all functions return no-op implementations. See [Observability — OpenTelemetry](/docs/plugins/observability#opentelemetry) for details.

## Security Hardening

### Security Headers

Summa automatically includes security headers (`X-Content-Type-Options`, `X-Frame-Options`, `Content-Security-Policy`, `Referrer-Policy`, `X-XSS-Protection`) on every API response. No configuration is needed.

For HSTS, configure it at your reverse proxy (Nginx, Cloudflare, ALB) rather than in application code, since local development runs over HTTP:

```nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
```

Or use the `onResponse` hook if you don't have a reverse proxy. See [Security Headers](/docs/api-reference#security-headers) for details.

### API Authentication

Use handler-level `onRequest` hooks or framework middleware:

```ts
const handler = createSummaHono(summa, {
  onRequest: (req) => {
    const key = req.headers?.["x-api-key"];
    if (!isValidKey(key)) {
      return { status: 401, body: { error: { code: "UNAUTHORIZED", message: "Invalid API key" } } };
    }
    return req;
  },
});
```

### Admin Endpoints

The admin plugin emits a **console warning** at startup if no `authorize` callback is provided. Always configure `authorize` in production:

```ts
admin({
  authorize: async (req) => {
    const token = req.headers?.["authorization"]?.replace("Bearer ", "");
    return token ? await verifyAdminToken(token) : false;
  },
})
```

### Rate Limiting

Choose a rate limiter backend based on your deployment:

| Backend | Best for | Shared across instances? |
|---------|----------|:-:|
| `memory` | Single instance, development | No |
| `database` | Multi-instance, no Redis | Yes |
| `secondary` (Redis) | Multi-instance, production (recommended) | Yes |

```ts
import { createRateLimiter } from "@summa-ledger/summa/api";

// For multi-instance: use Redis-backed rate limiting
const rateLimiter = createRateLimiter({
  window: 60,
  max: 100,
  storage: "secondary",  // Requires secondaryStorage in createSumma()
});
```

### CSRF Protection

Enable origin checking for browser-facing deployments:

```ts
const handler = createSummaHono(summa, {
  trustedOrigins: ["https://app.example.com"],
});
```

### Request Body Size Limits

Summa does not enforce request body size limits at the handler level — this is the responsibility of your framework or reverse proxy. Configure body size limits to prevent memory exhaustion from oversized payloads:

<Tabs items={["Express", "Fastify", "Hono", "Nginx"]}>
<Tab value="Express">

```ts
app.use(express.json({ limit: "1mb" }));
```

</Tab>
<Tab value="Fastify">

```ts
const app = Fastify({ bodyLimit: 1_048_576 }); // 1 MB
```

</Tab>
<Tab value="Hono">

```ts
import { bodyLimit } from "hono/body-limit";
app.use(bodyLimit({ maxSize: 1_048_576 })); // 1 MB
```

</Tab>
<Tab value="Nginx">

```nginx
client_max_body_size 1m;
```

</Tab>
</Tabs>

## Operations

### Health Checks

Summa exposes two health check endpoints:

**Liveness probe** — lightweight, no dependencies:

```bash
curl http://localhost:3000/api/ledger/ok
# {"ok":true}
```

**Readiness probe** — deep health check that verifies database connectivity and schema accessibility:

```bash
curl http://localhost:3000/api/ledger/health
# {
#   "status": "healthy",
#   "checks": {
#     "database": { "status": "ok" },
#     "schema": { "status": "ok", "workerLeases": 3 }
#   },
#   "timestamp": "2026-02-21T10:30:00.000Z"
# }
```

Returns `200` when healthy, `503` when degraded. Use `/ok` for load balancer liveness probes and `/health` for Kubernetes readiness probes.

```yaml title="kubernetes.yaml"
livenessProbe:
  httpGet:
    path: /api/ledger/ok
    port: 3000
  periodSeconds: 10
readinessProbe:
  httpGet:
    path: /api/ledger/health
    port: 3000
  periodSeconds: 30
```

### Recommended Plugin Set

For production deployments, start with:

```ts
// Core workers (hold expiry, idempotency cleanup, lease cleanup)
// run automatically — no plugin needed for basic cleanup
plugins: [
  auditLog(),                       // Compliance
  reconciliation(),                 // Integrity
  dataRetention(),                  // Retention policies for plugin tables
  observability(),                  // Metrics
  admin({ authorize: checkAuth }),  // Management
  openApi(),                        // Documentation
]
```

Add more plugins based on your requirements:
- **`velocityLimits()`** — if you need per-account transaction limits
- **`freezeExpiry()`** — if you use time-bounded account freezes
- **`outbox({ publisher })`** + **`dlqManager()`** — if you publish events to external systems
- **`hotAccounts()`** — if you have high-traffic accounts (> 1000 txn/min). **Strongly recommended** if you use `systemAccounts`
- **`snapshots()`** — if you need historical balance queries
- **`scheduledTransactions()`** — if you need future/recurring transactions
- **`dataRetention()`** — if you need configurable retention policies per table (see [Data Retention](/docs/plugins/data-retention))

### Integrity Verification

Run periodic integrity checks in production:

```bash
# Full verification (balances + hash chain)
npx summa verify --url "$DATABASE_URL"

# Quick balance-only check
npx summa verify --balances --url "$DATABASE_URL"
```

Schedule this as a cron job or CI step for continuous verification.
