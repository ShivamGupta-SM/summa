---
title: Reconciliation
description: Automated balance reconciliation to detect data inconsistencies.
icon: Scale
---

## Overview

The reconciliation plugin compares account balances against the sum of their entry records to detect mismatches caused by bugs, race conditions, or data corruption. It performs a comprehensive **5-step verification**.

## Setup

```ts
import { createSumma } from "@summa-ledger/summa";
import { reconciliation } from "@summa-ledger/summa/plugins";

const summa = createSumma({
  database: adapter,
  currency: "USD",
  plugins: [reconciliation()],
});
```

## Configuration

```ts
reconciliation({
  reconciliationInterval: "1d",      // Full reconciliation interval (default: "1d")
  fastReconciliationInterval: "1h",  // Fast integrity check interval (default: "1h")
  forceFullScan: false,              // Force Step 1 to scan all accounts (default: false)
  fullScanEveryNRuns: 7,             // Full scan every N incremental runs (default: 7)
  onBlockCheckpoint: async (anchor) => {
    // Called after each block checkpoint is created
    // Use this to anchor block hashes to an external store
    await externalStore.put(`block-${anchor.blockSequence}`, anchor);
  },
})
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `reconciliationInterval` | `string` | `"1d"` | How often the full 5-step reconciliation runs |
| `fastReconciliationInterval` | `string` | `"1h"` | How often the fast integrity check runs |
| `forceFullScan` | `boolean` | `false` | Force Step 1 to scan all accounts regardless of watermark |
| `fullScanEveryNRuns` | `number` | `7` | Run a full account scan every N incremental runs as a safety net |
| `onBlockCheckpoint` | `function` | — | Callback for external anchoring of block hashes |

The plugin registers three background workers:

| Worker | Interval | Lease Required | Description |
|--------|----------|:-:|-------------|
| `daily-reconciliation` | Configurable | Yes | Runs the full 5-step verification |
| `fast-reconciliation` | Configurable | Yes | Lightweight double-entry + block chain check |
| `block-checkpoint` | `1h` | Yes | Creates hash chain checkpoints |

## Incremental Reconciliation

By default, Step 1 (per-account balance verification) runs incrementally — it only checks accounts that had activity since the last reconciliation run instead of scanning every account.

**How it works:**
1. The watermark tracks `lastEntryCreatedAt` — the timestamp of the last processed entry
2. On each run, `SELECT DISTINCT account_id FROM entry_record WHERE created_at > $watermark` finds only active accounts
3. Only those accounts are verified, dramatically reducing scan time
4. Every `fullScanEveryNRuns` runs (default: 7), a full scan is triggered as a safety net
5. The `incremental_run_count` is tracked on the watermark and resets after each full scan

**First run:** Always a full scan (no watermark exists yet).

Set `forceFullScan: true` to always scan all accounts (useful for debugging or after data migrations).

## Verification Steps

The reconciliation process runs these checks:

1. **Per-account balance verification** — stored balance matches SUM of all entries (incremental by default — only active accounts)
2. **Duplicate entry detection** — no two entries should be identical
3. **Lock version monotonicity** — account lock versions must be monotonically increasing
4. **System account balance with hot entries** — includes pending hot account entries in the sum
5. **Hash chain verification** — uses checkpoint-aware verification (`verifyHashChainFromCheckpoint`) to only scan events after the last sealed block checkpoint, making this O(delta) instead of O(all events)

## Fast Reconciliation

The `fast-reconciliation` worker runs a lightweight integrity check (default: every hour) that covers:

- **Step 0**: Double-entry balance verification (incremental — only new entries since last run)
- **Step 3**: Block hash chain verification (last 2 hours of blocks)

This reduces the detection gap from 24 hours to 1 hour without the cost of a full reconciliation scan. Fast reconciliation results are stored with `run_type: "fast"` in the reconciliation results table.

## External Anchoring

The `onBlockCheckpoint` callback fires after each block checkpoint is created, providing a `BlockCheckpointAnchor` object:

```ts
interface BlockCheckpointAnchor {
  blockHash: string;         // SHA-256/HMAC hash of the block
  merkleRoot: string;        // Merkle root of events in this block
  blockSequence: number;     // Monotonically increasing block number
  eventCount: number;        // Number of events in this block
  fromEventSequence: number; // First event sequence in the block
  toEventSequence: number;   // Last event sequence in the block
  timestamp: string;         // ISO 8601 timestamp
}
```

Write these anchors to an external store (S3, blockchain, separate database) to provide cryptographic proof that the ledger state was not altered retroactively. Verify later with:

```ts
const result = await summa.events.verifyExternalAnchor(
  blockSequence,
  externallyStoredBlockHash,
);
// result.valid === true means the database hash matches your external copy
```

## Querying Reconciliation Status

Use the standalone `getReconciliationStatus` function to query the current watermark and recent reconciliation results:

```ts
import { getReconciliationStatus } from "@summa-ledger/summa/plugins";

const status = await getReconciliationStatus(summa.$context);

// Watermark — last run info
console.log(status.watermark.lastRunDate);      // ISO timestamp
console.log(status.watermark.lastMismatches);    // 0 = healthy

// Recent results — paginated
for (const result of status.recentResults) {
  console.log(result.run_date, result.status, result.total_mismatches);
  console.log(`Duration: ${result.duration_ms}ms`);
}
```

### Parameters

```ts
const status = await getReconciliationStatus(ctx, {
  limit: 10,    // Max results (default: 10, max: 100)
  offset: 0,    // Pagination offset (default: 0)
});
```

### Return Type

```ts
{
  watermark: {
    lastEntryCreatedAt: string | null;  // Last processed entry timestamp
    lastRunDate: string | null;         // Last reconciliation run
    lastMismatches: number;             // Mismatches found in last run
  };
  recentResults: Array<{
    run_date: string;
    status: string;                     // "passed" | "failed"
    total_mismatches: number;
    step0_result: Record<string, unknown>;   // Per-txn double-entry
    step0b_result: Record<string, unknown>;  // Duplicate detection
    step0c_result: Record<string, unknown>;  // Lock version check
    step1_result: Record<string, unknown>;   // User account balances
    step2_result: Record<string, unknown>;   // System account balances
    step3_result: Record<string, unknown>;   // Hash chain checkpoints
    duration_ms: number;
  }>;
}
```

## CLI Verification

```bash
# Run all integrity checks
npx summa verify

# Balance checks only
npx summa verify --balances
```

The CLI shows a summary: `5 passed / 0 failed / 0 skipped`.
