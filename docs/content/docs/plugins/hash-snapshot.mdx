---
title: Verification Snapshots
description: O(recent events) hash chain verification via per-aggregate snapshots.
icon: ShieldCheck
---

## Overview

The verification snapshots plugin creates periodic **hash chain snapshots** for each aggregate, reducing verification from O(all events) to O(events since last snapshot). This dramatically speeds up daily reconciliation — from hours to minutes on large ledgers.

<Callout type="info" title="Not to be confused with balance snapshots">
  This plugin creates *cryptographic verification* snapshots (hash chain optimization). For point-in-time **balance snapshots** used in reporting, see the [Snapshots plugin](/docs/plugins/snapshots).
</Callout>

Each snapshot records the latest verified `aggregate_version` and `hash` for an aggregate. When verifying, the chain scan starts from the snapshot instead of from the beginning.

## Setup

```ts
import { createSumma } from "summa";
import { verificationSnapshots } from "summa/plugins";

const summa = createSumma({
  database: adapter,
  currency: "USD",
  plugins: [verificationSnapshots()],
});
```

## Configuration

```ts
verificationSnapshots({
  snapshotInterval: "6h",   // How often the worker runs (default: "6h")
  batchSize: 500,           // Max aggregates to snapshot per run (default: 500)
})
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `snapshotInterval` | `string` | `"6h"` | Worker run interval (e.g., `"6h"`, `"1d"`, `"30m"`) |
| `batchSize` | `number` | `500` | Max aggregates processed per worker run |

## How It Works

1. **Background worker** runs every 6 hours (configurable) with a distributed lease
2. Finds aggregates with events newer than their latest snapshot (via `LEFT JOIN` on `hash_snapshot`)
3. For each stale aggregate, reads the latest event's `aggregate_version` and `hash`
4. Upserts the snapshot — only updates if the new version is higher than the existing one

## Schema

The plugin creates a `hash_snapshot` table:

| Column | Type | Description |
|--------|------|-------------|
| `id` | `uuid` | Primary key |
| `ledger_id` | `text` | Ledger identifier |
| `aggregate_type` | `text` | Aggregate type (e.g., "account", "transaction") |
| `aggregate_id` | `text` | Aggregate ID |
| `snapshot_version` | `bigint` | Last verified aggregate version |
| `snapshot_hash` | `text` | Hash at the snapshot version |
| `event_count` | `integer` | Total events for this aggregate at snapshot time |
| `created_at` | `timestamp` | When the snapshot was created/updated |

Unique constraint on `(ledger_id, aggregate_type, aggregate_id)`.

## Verification API

The infrastructure module exposes functions for snapshot-aware verification:

```ts
import { verifyFromSnapshot, createHashSnapshot } from "summa/infrastructure/hash-snapshot";

// Verify using snapshot (falls back to full scan if no snapshot exists)
const result = await verifyFromSnapshot(ctx, "account", accountId, ledgerId);
// { valid: true, eventCount: 15000, usedSnapshot: true, skippedViaSnapshot: 14800 }

// Manually create a snapshot
const snapshot = await createHashSnapshot(ctx, "account", accountId, ledgerId);
```

## Performance Impact

| Scenario | Without snapshots | With snapshots |
|----------|:-:|:-:|
| 10K events/aggregate | ~200ms | ~5ms |
| 100K events/aggregate | ~2s | ~10ms |
| Daily reconciliation (1M aggregates) | ~14 hours | ~1.5 hours |

The improvement is proportional to how recently the snapshot was created relative to the aggregate's total event count.

## Interaction with Reconciliation

The reconciliation plugin (`reconciliation()`) uses `verifyHashChain()` by default. When the hash snapshot plugin is registered, you can use `verifyFromSnapshot()` as a faster alternative for per-aggregate checks. The block-level checkpoint verification (`verifyRecentBlocks()`) is unaffected — it operates at the block level, not per-aggregate.
