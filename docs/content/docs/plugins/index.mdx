---
title: Plugins
description: Extend Summa with reconciliation, snapshots, velocity limits, and more.
icon: PuzzlePiece
---

## Overview

Summa's plugin system extends the core ledger with additional functionality through **lifecycle hooks**, **background workers**, and **database schema extensions**. Plugins are composable — enable only what you need.

```ts
import {
  auditLog,
  reconciliation,
  snapshots,
  velocityLimits,
  freezeExpiry,
  outbox,
  dlqManager,
  hotAccounts,
  scheduledTransactions,
  admin,
  openApi,
  observability,
  statements,
  periodClose,
  financialReporting,
  fxEngine,
  glSubLedger,
  approvalWorkflow,
  batchImport,
  accrualAccounting,
  dataRetention,
  versionRetention,
  i18n,
  mcp,
  identity,
  apiKeys,
  balanceMonitor,
  backup,
  search,
  batchEngine,
} from "summa/plugins";

const summa = createSumma({
  database: adapter,
  currency: "USD",
  // Hold expiry, idempotency cleanup, and lease cleanup run automatically
  // as core workers — no plugin needed
  plugins: [
    auditLog(),
    reconciliation(),
    snapshots(),
    velocityLimits(),
    freezeExpiry(),
    outbox({ publisher: myPublisher }),
    dlqManager(),
    hotAccounts(),
    scheduledTransactions(),
    admin({ authorize: (req) => req.headers?.["x-admin-key"] === process.env.ADMIN_KEY }),
    openApi(),
    observability(),
    statements(),
  ],
});
```

## Available Plugins

| Plugin | Category | Background Worker | Description |
|--------|----------|:-:|-------------|
| [`auditLog`](/docs/plugins/audit-log) | Compliance | Yes | Immutable audit trail for all ledger operations |
| [`reconciliation`](/docs/plugins/reconciliation) | Integrity | Yes | Automated balance reconciliation with 5-step verification |
| [`snapshots`](/docs/plugins/snapshots) | Reporting | Yes | Point-in-time balance snapshots for historical queries |
| [`velocityLimits`](/docs/plugins/velocity-limits) | Security | Yes | Per-transaction, daily, and monthly amount limits |
| [`freezeExpiry`](/docs/plugins/freeze-expiry) | Automation | Yes | Auto-unfreeze accounts after their `frozen_until` TTL |
| [`outbox`](/docs/plugins/outbox) | Integration | Yes | Transactional outbox for reliable event publishing |
| [`dlqManager`](/docs/plugins/dlq-manager) | Operations | Yes | Dead letter queue for failed event processing |
| [`hotAccounts`](/docs/plugins/hot-accounts) | Performance | Yes | Optimistic concurrency for high-traffic accounts |
| [`scheduledTransactions`](/docs/plugins/scheduled-transactions) | Automation | Yes | Future and recurring transaction scheduling |
| [`admin`](/docs/plugins/admin) | Management | No | Elevated admin endpoints with authorization and dashboard stats |
| [`openApi`](/docs/plugins/open-api) | Documentation | No | Auto-generated OpenAPI 3.1 specification |
| [`observability`](/docs/plugins/observability) | Monitoring | No | Distributed tracing and Prometheus metrics via `/metrics` endpoint |
| [`statements`](/docs/plugins/statements) | Reporting | Yes | Account statement generation with JSON, CSV, and PDF download |
| [`periodClose`](/docs/plugins/period-close) | Compliance | No | Lock accounting periods to prevent backdated transactions |
| [`financialReporting`](/docs/plugins/financial-reporting) | Reporting | No | Trial balance, balance sheet, and income statement |
| [`fxEngine`](/docs/plugins/fx-engine) | Finance | Yes | Auto-resolves exchange rates for cross-currency transfers, rate caching, quotes, and gain/loss tracking |
| [`glSubLedger`](/docs/plugins/gl-sub-ledger) | Finance | Yes | General ledger / sub-ledger separation with reconciliation |
| [`approvalWorkflow`](/docs/plugins/approval-workflow) | Compliance | Yes | Maker-checker dual authorization for sensitive transactions |
| [`batchImport`](/docs/plugins/batch-import) | Operations | Yes | Bulk CSV/JSON transaction import with staged validation |
| [`accrualAccounting`](/docs/plugins/accrual-accounting) | Finance | Yes | Revenue/expense recognition over time |
| [`dataRetention`](/docs/plugins/data-retention) | Operations | Yes | Unified data retention policies across all tables |
| [`versionRetention`](/docs/plugins/version-retention) | Performance | Yes | Archive and prune old `account_balance_version` rows to keep the table bounded |
| [`i18n`](/docs/plugins/i18n) | Localization | No | Multi-locale error message translation with Accept-Language detection |
| [`mcp`](/docs/plugins/mcp) | Integration | No | Model Context Protocol tools for AI agent access to the ledger |
| [`identity`](/docs/plugins/identity) | Compliance | No | KYC identity management with AES-256-GCM PII tokenization |
| [`apiKeys`](/docs/plugins/api-keys) | Security | Yes | SHA-256 hashed API key management with scoped permissions and rotation |
| [`balanceMonitor`](/docs/plugins/balance-monitor) | Monitoring | No | Real-time condition-based balance alerts and threshold triggers |
| [`backup`](/docs/plugins/backup) | Operations | Yes | Automated PostgreSQL backups with local disk and S3 storage |
| [`search`](/docs/plugins/search) | Integration | Yes | Native PostgreSQL full-text search (zero-dependency) with optional Typesense and Meilisearch backends |
| [`batchEngine`](/docs/scaling#transaction-batching-batch-engine) | Performance | No | TigerBeetle-inspired transaction batching for 100,000+ TPS |

## Plugin Architecture

Every plugin implements the `SummaPlugin` interface:

```ts
interface SummaPlugin {
  id: string;                    // Unique identifier
  dependencies?: string[];       // Plugin IDs that must load first
  init?: (ctx) => Promise<void>; // Called on startup

  // HTTP endpoints contributed by the plugin
  endpoints?: PluginEndpoint[];

  // Lifecycle hooks
  hooks?: {
    beforeTransaction?: (params) => Promise<void>;
    afterTransaction?: (params) => Promise<void>;
    beforeAccountCreate?: (params) => Promise<void>;
    afterAccountCreate?: (params) => Promise<void>;
    beforeHoldCreate?: (params) => Promise<void>;
    afterHoldCommit?: (params) => Promise<void>;
  };

  // Matcher-based operation hooks (generic extension of lifecycle hooks)
  operationHooks?: {
    before?: Array<{ matcher: (op) => boolean; handler: (ctx) => Promise<void | { cancel: true; reason: string }> }>;
    after?: Array<{ matcher: (op) => boolean; handler: (ctx) => Promise<void> }>;
  };

  // HTTP-level request/response interceptors
  onRequest?: (req) => req | response;  // Return response to short-circuit
  onResponse?: (req, res) => res;       // Modify response before sending

  // Background workers
  workers?: SummaWorkerDefinition[];

  // Scheduled tasks (user provides cron runner)
  scheduledTasks?: Array<{ id: string; description: string; handler: (ctx) => Promise<void>; suggestedInterval: string }>;

  // Database tables (auto-created by migrate push)
  schema?: Record<string, TableDefinition>;

  // Custom error codes
  $ERROR_CODES?: Record<string, RawErrorCode>;

  // Type inference for TypeScript
  $Infer?: Record<string, unknown>;

  // Rate limiting rules for specific operations
  rateLimit?: Array<{ operation: string | ((op) => boolean); window: number; max: number }>;
}
```

### Lifecycle Hooks

Hooks run **synchronously within the database transaction** — if a `beforeTransaction` hook throws, the entire transaction is rolled back.

| Hook | When it runs | Can cancel? |
|------|-------------|:-:|
| `beforeTransaction` | Before any credit/debit/transfer | Yes — throw to reject |
| `afterTransaction` | After transaction is posted | No |
| `beforeAccountCreate` | Before account creation | Yes |
| `afterAccountCreate` | After account is created | No |
| `beforeHoldCreate` | Before hold creation | Yes |
| `afterHoldCommit` | After hold is committed | No |

Example — the velocity limits plugin uses `beforeTransaction` to check limits:

```ts
hooks: {
  beforeTransaction: async ({ type, amount, holderId, category, ctx }) => {
    const result = await checkLimits(ctx, holderId, amount, category);
    if (!result.allowed) {
      throw new SummaError("LIMIT_EXCEEDED", result.message);
    }
  },
}
```

### Operation Hooks

In addition to the named lifecycle hooks, plugins can use **matcher-based operation hooks** — a generic pattern that matches any operation type:

```ts
{
  id: "my-compliance-plugin",
  operationHooks: {
    before: [
      {
        matcher: (op) => op.type.startsWith("transaction."),
        handler: async ({ operation, context }) => {
          const result = await complianceCheck(operation);
          if (!result.ok) {
            return { cancel: true, reason: result.message };
          }
        },
      },
    ],
    after: [
      {
        matcher: (op) => op.type === "account.create",
        handler: async ({ operation, context }) => {
          await notifyOnboarding(operation.params);
        },
      },
    ],
  },
}
```

**Available operation types:** `account.create`, `account.freeze`, `account.unfreeze`, `account.close`, `transaction.credit`, `transaction.debit`, `transaction.transfer`, `transaction.refund`, `transaction.correct`, `transaction.adjust`, `transaction.journal`, `hold.create`, `hold.commit`, `hold.void`

A `before` hook returning `{ cancel: true, reason }` rejects the operation with `INVALID_ARGUMENT`.

### Plugin Rate Limiting

Plugins can declare rate limiting rules for specific operations:

```ts
{
  id: "my-plugin",
  rateLimit: [
    { operation: "transaction.transfer", window: 60, max: 100 },
    { operation: (op) => op.startsWith("hold."), window: 10, max: 50 },
  ],
}
```

| Field | Type | Description |
|-------|------|-------------|
| `operation` | `string \| (op: string) => boolean` | Operation type or matcher function |
| `window` | `number` | Window size in seconds |
| `max` | `number` | Maximum operations allowed in window |

### Plugin Dependencies

Plugins can declare dependencies on other plugins. Summa validates that all required plugins are registered and sorts them topologically at startup.

```ts
{
  id: "my-plugin",
  dependencies: ["audit-log", "reconciliation"],
  // ...
}
```

If a required plugin is missing, `createSumma()` throws immediately:

```
Plugin "my-plugin" requires plugin "audit-log" which is not registered
```

Duplicate plugin IDs are also detected at startup — if two plugins share the same `id`, `createSumma()` throws:

```
Duplicate plugin ID: "my-plugin"
```

### Request/Response Interceptors

Plugins can intercept HTTP requests and responses at the handler level — before and after route matching. This is how the `observability` plugin adds tracing and metrics.

```ts
{
  id: "my-auth-plugin",
  onRequest: (req) => {
    if (!req.headers?.["authorization"]) {
      return { status: 401, body: { error: "Unauthorized" } };
    }
    return req; // Continue to route handler
  },
  onResponse: (req, res) => {
    return { ...res, headers: { ...res.headers, "X-Custom": "value" } };
  },
}
```

- `onRequest` runs **after** CSRF/rate-limiting, **before** route matching. Return a response object to short-circuit.
- `onResponse` runs **after** the route handler, in **reverse plugin order** (middleware stack unwinding).

### Background Workers

Workers run on configurable intervals with **distributed lease** support — in a multi-instance deployment, only one instance runs each worker.

```ts
interface SummaWorkerDefinition {
  id: string;              // Unique worker ID
  handler: (ctx) => Promise<void>;
  interval: string;        // "5s" | "1m" | "30m" | "1h" | "1d"
  leaseRequired?: boolean; // Prevents duplicate runs in cluster
}
```

Start all workers (core + plugin):

```ts
await summa.workers.start();

// Graceful shutdown
process.on("SIGTERM", async () => {
  await summa.workers.stop();
});
```

`summa.workers.start()` starts both **core workers** and **plugin workers**. Worker intervals support `"5s"`, `"1m"`, `"30m"`, `"1h"`, `"1d"` format. A ±25% jitter is applied to prevent thundering herd effects. Lease duration is `2x` the worker interval.

#### Core Workers

Core workers run automatically regardless of which plugins are registered. They handle cleanup for tables that core itself writes to:

| Worker | Interval | Description |
|--------|----------|-------------|
| `core:hold-expiry` | `5m` | Expires holds past `hold_expires_at` (uses `FOR UPDATE SKIP LOCKED`) |
| `core:idempotency-cleanup` | `1h` | Removes expired idempotency keys |
| `core:lease-cleanup` | `6h` | Removes stale worker lease records |

Configure intervals via `coreWorkers` in [`createSumma()`](/docs/configuration#core-workers). Set any worker to `false` to disable it (only if you handle cleanup externally).

#### Plugin Workers

Plugin workers only run when their plugin is registered. Examples include outbox delivery, reconciliation checks, snapshot creation, and data retention cleanup. Each plugin's docs list its workers. The [outbox plugin](/docs/plugins/outbox) also handles `processed_event` dedup cleanup as part of its `outbox-cleanup` worker.

### Type Inference

Plugins can extend the Summa instance with type-safe properties via `$Infer`:

```ts
// Access plugin-provided types
type AuditEntry = typeof summa.$Infer.AuditLogEntry;
type OutboxStats = typeof summa.$Infer.OutboxStats;
type HotStats = typeof summa.$Infer.HotAccountStats;
type DlqStats = typeof summa.$Infer.DlqStats;
type FailedEvent = typeof summa.$Infer.FailedEvent;
```

## Recommended Plugin Combinations

### Minimum Production Setup

```ts
// Core workers (hold expiry, idempotency cleanup, lease cleanup)
// run automatically — no plugins needed for basic cleanup
plugins: [
  auditLog(),         // Compliance and debugging
  reconciliation(),   // Data integrity verification
]
```

### Full Production Setup

```ts
plugins: [
  auditLog(),
  reconciliation(),
  snapshots(),
  velocityLimits(),
  freezeExpiry(),
  outbox({ publisher: myPublisher }),
  dlqManager(),
  hotAccounts(),
  observability(),
  admin({ authorize: checkAdminAuth }),
  openApi(),
]
```

### Testing / Development

```ts
plugins: []  // No plugins needed for basic testing
```

### Plugin Endpoints

Plugins can contribute HTTP endpoints that are automatically routed through the API handler:

```ts
interface PluginEndpoint {
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  path: string;
  handler: (req: PluginApiRequest, ctx: SummaContext) => Promise<PluginApiResponse>;
}
```

For example, the `admin` plugin adds 13 management endpoints, and the `openApi` plugin serves the generated spec at `/openapi.json`. See [HTTP API](/docs/api-reference#plugin-endpoints) for the full list.

See individual plugin pages for configuration options and detailed documentation.
