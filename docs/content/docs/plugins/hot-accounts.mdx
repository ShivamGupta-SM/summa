---
title: Hot Accounts
description: Optimistic concurrency for high-traffic accounts.
icon: Fire
---

## Overview

The hot accounts plugin uses **optimistic concurrency control** to reduce contention on accounts that receive many concurrent transactions (e.g., platform fee accounts, treasury accounts, marketplace settlement accounts).

Instead of pessimistic row-level locks, hot accounts use a `lock_version` counter. When a concurrent update detects a version mismatch, it retries with the latest state. This dramatically reduces lock wait times.

## Setup

```ts
import { createSumma } from "@summa-ledger/summa";
import { hotAccounts } from "@summa-ledger/summa/plugins";

const summa = createSumma({
  database: adapter,
  currency: "USD",
  plugins: [hotAccounts()],
});
```

<Callout type="warn" title="Required when using system accounts">
  If you configure system accounts (accounts with `is_system = true`, e.g., `@World`, `@Fees`), Summa logs a startup warning if the hot accounts plugin is not registered. System accounts typically receive high transaction volume and benefit significantly from optimistic concurrency. While the warning is non-blocking, registering this plugin is strongly recommended for production deployments with system accounts.
</Callout>

## Configuration

```ts
hotAccounts({
  batchSize: 1000,          // Entries processed per aggregation batch (default: 1000)
  retentionHours: 24,       // Keep watermark history for 24 hours (default)
})
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `batchSize` | `number` | `1000` | Entries processed per aggregation batch |
| `retentionHours` | `number` | `24` | Hours to retain watermark history for replay safety |

## How It Works

1. Transactions to hot accounts write entries to the `entry` table without immediately updating the `account` balance
2. This avoids row-level lock contention — many concurrent transactions can write simultaneously
3. A background worker uses watermark-based batching to periodically aggregate pending entries and applies the net balance change to the `account` row
4. The reconciliation plugin includes pending entries in its balance verification

## How Accounts Become Hot

Hot account detection is **automatic**. When an account exceeds `advanced.hotAccountThreshold` transactions per minute (default: 1000), the core transaction pipeline defers balance updates on the `account` row and relies on watermark-based batching to aggregate pending entries from the `entry` table.

No manual marking is needed — accounts transition to the hot path transparently based on traffic patterns.

## Realtime Balance

System account (accounts with `is_system = true` in the unified `account` table) balances are updated every flush cycle (~30s). If you need the up-to-the-moment balance including unflushed entries, use `getRealtimeBalance()`:

```ts
import { getRealtimeBalance } from "@summa-ledger/summa/plugins";

const balance = await getRealtimeBalance(summa.$context, "@Fees");
console.log(balance.committedBalance);   // Last flushed balance on the account row
console.log(balance.pendingDelta);       // SUM of unflushed entries past the watermark
console.log(balance.realtimeBalance);    // committedBalance + pendingDelta
console.log(balance.pendingEntryCount);  // Number of unflushed entries
console.log(balance.lastFlushAt);        // ISO timestamp of last flush (or null)
```

This runs a single CTE query — no extra round-trips. The `realtimeBalance` field is what you'd see if all pending entries were flushed right now.

Also available via API:

```
GET /accounts/:identifier/realtime-balance
```

### `RealtimeBalance` type

```ts
interface RealtimeBalance {
  committedBalance: number;
  pendingDelta: number;
  realtimeBalance: number;
  pendingEntryCount: number;
  lastFlushAt: string | null;
}
```

## Querying Hot Account Stats

```ts
import { getHotAccountStats } from "@summa-ledger/summa/plugins";

const stats = await getHotAccountStats(summa.$context);
console.log(stats.pending);           // Entries awaiting aggregation
console.log(stats.processed);         // Successfully aggregated entries
console.log(stats.failedSequences);   // Failed aggregation attempts
```

## Type Inference

```ts
import type { HotAccountStats } from "@summa-ledger/summa/plugins";

type Stats = typeof summa.$Infer.HotAccountStats;
// { pending: number, processed: number, failedSequences: number }
```

## When to Use

Use hot accounts for:
- **Platform fee accounts** — every transaction on your platform credits this account
- **Treasury/float accounts** — high-volume settlement accounts
- **Marketplace escrow** — accounts receiving thousands of concurrent payments

Don't use hot accounts for regular user accounts — the overhead isn't worth it for accounts with low concurrency.
