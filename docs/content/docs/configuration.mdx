---
title: Configuration
description: All Summa configuration options, system accounts, and advanced settings.
icon: Cog
---

## Overview

Summa is configured through `createSumma()` which accepts a `SummaOptions` object:

```ts
import { createSumma } from "@summa-ledger/summa";

const summa = createSumma({
  database: adapter,          // Required — database adapter
  currency: "USD",            // Default currency (ISO 4217)
  ledgerId: "ledger-uuid",    // Ledger ID for multi-tenancy
  functionalCurrency: "USD",  // Reporting consolidation currency
  schema: "summa",            // PostgreSQL schema (default: "summa")
  systemAccounts: { ... },    // System account definitions
  plugins: [ ... ],           // Plugin instances
  advanced: { ... },          // Performance and safety tuning
  logger: customLogger,       // Custom logger implementation
  secondaryStorage: redis,    // Optional Redis/KV for rate limiting
});
```

## Core Options

### `database` (required)

The database adapter instance. Summa supports four adapters:

```ts
import { drizzleAdapter } from "@summa-ledger/drizzle-adapter";
import { prismaAdapter } from "@summa-ledger/prisma-adapter";
import { kyselyAdapter } from "@summa-ledger/kysely-adapter";
import { memoryAdapter } from "@summa-ledger/memory-adapter";

// Pass a constructed adapter
database: drizzleAdapter(db)

// Or a factory function (lazy initialization)
database: () => drizzleAdapter(drizzle(process.env.DATABASE_URL!))
```

See [Adapters](/docs/adapters/drizzle) for adapter-specific setup.

### `readDatabase`

Optional read replica adapter. When configured, all read-only operations (account/transaction listing, search, statements, balance lookups) are routed to the replica, freeing the primary for writes.

```ts
readDatabase: () => drizzleAdapter(drizzle(process.env.DATABASE_REPLICA_URL!))
```

When omitted, all reads go to the primary `database` adapter. See [Scaling — Read Replicas](/docs/scaling#read-replicas) for architecture details.

### `currency`

Default ISO 4217 currency code. Defaults to `"USD"`. This is used when creating accounts without an explicit currency.

```ts
currency: "INR"  // Indian Rupees — amounts in paise
currency: "EUR"  // Euros — amounts in cents
currency: "JPY"  // Japanese Yen — amounts in yen (no subdivision)
```

All amounts throughout Summa are in the **smallest currency unit** (cents, paise, etc.).

### `functionalCurrency`

The currency used for consolidated financial reporting. Defaults to the value of `currency`. This is relevant when you have accounts in multiple currencies and need to generate unified reports (e.g., trial balance, balance sheet) in a single currency.

```ts
functionalCurrency: "USD"  // All reports consolidate to USD
```

<Callout type="info" title="Multi-currency support">
  Summa supports creating accounts in any of 50+ ISO 4217 currencies. Cross-currency transfers are supported — rates are auto-resolved when the [FX Engine plugin](/docs/plugins/fx-engine) is registered, or can be provided manually. See [Transactions — Cross-Currency Transfers](/docs/transactions#cross-currency-transfers) for details.
</Callout>

### `schema`

PostgreSQL schema namespace for all Summa tables. Defaults to `"summa"`, which keeps all ledger tables isolated from your application's `public` schema.

```ts
schema: "summa"   // Default — tables in "summa"."account", etc.
schema: "ledger"  // Custom — tables in "ledger"."account", etc.
schema: "public"  // All tables in the public schema (not recommended)
```

All table references are automatically qualified at runtime (e.g., `"summa"."account"`). The CLI `migrate push` command creates the schema with `CREATE SCHEMA IF NOT EXISTS` before applying migrations.

<Callout type="info" title="Schema naming">
  The schema name must contain only alphanumeric characters and underscores, and must start with a letter or underscore. Examples: `"summa"`, `"ledger"`, `"fin_data"`.
</Callout>

<Callout type="warn" title="Changing the schema after deployment">
  If you change the schema name on an existing deployment, you must migrate the tables manually. Summa does not automatically move tables between schemas.
</Callout>

### `ledgerId`

The ledger ID for multi-tenant deployments. When set, all operations are scoped to this ledger. You can also pass `ledgerId` per-request via the request body or `X-Ledger-Id` header.

```ts
ledgerId: "your-ledger-uuid"  // Scope all operations to this ledger
```

Create ledgers programmatically:

```ts
const ledger = await summa.ledgers.create({ name: "Acme Corp" });
// Use ledger.id in subsequent calls
```

See [Multi-Tenancy](/docs/multi-tenancy) for the full guide on ledger-as-namespace isolation.

## Extensibility

### `systemAccounts`

System accounts represent your platform's internal accounts. They are created automatically when a ledger is created and used as the counterparty for credits and debits. Each ledger gets its own set of system accounts.

```ts
// Use string shorthand (identifier = name)
systemAccounts: {
  World: "@World",
  Fees: "@Fees",
  Suspense: "@Suspense",
}

// Or use the full definition
systemAccounts: {
  World: { identifier: "@World", name: "World Account" },
  Fees: { identifier: "@Fees", name: "Platform Fee Account" },
  Revenue: { identifier: "@Revenue", name: "Revenue Account" },
  Suspense: { identifier: "@Suspense", name: "Suspense Account" },
}
```

When you call `transactions.credit()`, funds come from the `@World` system account by default. You can specify a different source:

```ts
await summa.transactions.credit({
  holderId: "user_123",
  amount: 100_00,
  reference: "deposit-001",
  sourceSystemAccount: "@Revenue",  // Specific system account
});
```

### `plugins`

Array of plugin instances. Plugins extend Summa with additional functionality through lifecycle hooks and background workers.

```ts
import {
  accrualAccounting,
  admin,
  approvalWorkflow,
  auditLog,
  batchImport,
  dataRetention,
  dlqManager,
  financialReporting,
  fxEngine,
  glSubLedger,
  freezeExpiry,
  hotAccounts,
  observability,
  openApi,
  outbox,
  periodClose,
  reconciliation,
  scheduledTransactions,
  snapshots,
  statements,
  velocityLimits,
} from "@summa-ledger/summa/plugins";

plugins: [
  auditLog(),
  reconciliation(),
  snapshots(),
  velocityLimits(),
  freezeExpiry(),
  outbox({ publisher: myPublisher }),
  dlqManager(),
  hotAccounts(),
  scheduledTransactions(),
  dataRetention({ auditLogs: "7y" }),
  openApi({ title: "My Ledger API" }),
  observability(),
  statements(),
  periodClose(),
  financialReporting(),
  fxEngine({ rateProvider: myRateProvider }),
  glSubLedger(),
  approvalWorkflow({ rules: [] }),
  batchImport(),
  accrualAccounting(),
  // versionRetention — removed in v2 (balances are mutable on account row)
]
```

Plugins are automatically sorted by their declared dependencies using topological sort — you can list them in any order. If a plugin declares a dependency that isn't registered, or if there's a circular dependency, `createSumma()` throws immediately.

See [Plugins](/docs/plugins) for details on each plugin.

## Core Workers

Summa automatically runs background workers for essential cleanup tasks. These run when you call `summa.workers.start()` — no plugins needed.

```ts
coreWorkers: {
  holdExpiry: { interval: "5m" },        // Default: "5m" — expires holds past hold_expires_at
  idempotencyCleanup: { interval: "1h" }, // Default: "1h" — removes expired idempotency keys
  leaseCleanup: { interval: "6h" },       // Default: "6h" — removes stale worker leases
}
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `holdExpiry` | `boolean \| { interval?: string }` | `true` | Hold expiry worker. `false` to disable |
| `idempotencyCleanup` | `boolean \| { interval?: string }` | `true` | Idempotency key cleanup worker. `false` to disable |
| `leaseCleanup` | `boolean \| { interval?: string }` | `true` | Worker lease cleanup. `false` to disable |

All core workers are enabled by default. Disable individual workers only if you handle cleanup externally (e.g., via a cron job).

### Cleanup Ownership

Every table that Summa writes to has a clear cleanup owner:

| Table | Cleanup Owner | Notes |
|-------|---------------|-------|
| `hold` (expired) | **Core worker** (`core:hold-expiry`) | Core sets `hold_expires_at`, core expires them |
| `idempotency_key` | **Core worker** (`core:idempotency-cleanup`) | Core writes idempotency keys on every operation |
| `worker_lease` | **Core worker** (`core:lease-cleanup`) | Core manages distributed worker leases |
| `outbox` | [**Outbox plugin**](/docs/plugins/outbox) (`outbox-cleanup`) | Outbox owns the event delivery pipeline |
| `audit_log` | [**Data retention plugin**](/docs/plugins/data-retention) | Optional — configure `auditLogs` |
| `fx_rate_quote` | [**Data retention plugin**](/docs/plugins/data-retention) | Optional — configure `fxQuotes` |

The principle: **if core writes to a table, core cleans it up**. Plugin-owned tables are cleaned by their respective plugins.

## Advanced Tuning

### `advanced`

Performance and safety tuning options:

```ts
advanced: {
  hotAccountThreshold: 1000,       // Txns/min before hot account kicks in
  idempotencyTTL: 86_400_000,      // 24 hours (ms) — idempotency key expiry
  transactionTimeoutMs: 5000,      // Database transaction timeout
  lockTimeoutMs: 3000,             // Advisory lock acquisition timeout
  maxTransactionAmount: 1_000_000_000_00,  // $10M max per transaction
  hmacSecret: process.env.SUMMA_HMAC_SECRET,  // HMAC secret for tamper-proof hashes
  verifyEntryHashOnRead: true,     // Verify entry hash integrity on every read
  lockRetryCount: 3,               // Retry on lock contention
  lockRetryBaseDelayMs: 50,        // Exponential backoff base delay
  lockRetryMaxDelayMs: 500,        // Max backoff delay
  lockMode: "nowait",              // Fail-fast + retry for contested accounts
  optimisticRetryCount: 3,         // Retries for optimistic lock version conflicts
  enableBatching: false,           // Transaction batching for extreme throughput
  batchMaxSize: 200,               // Max transactions per batch
  batchFlushIntervalMs: 5,         // Max ms before incomplete batch is flushed
}
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `hotAccountThreshold` | `number` | `1000` | Transactions per minute before an account is treated as "hot" |
| `idempotencyTTL` | `number` | `86400000` | Idempotency key expiry in milliseconds (24 hours) |
| `transactionTimeoutMs` | `number` | `5000` | Maximum time for a database transaction |
| `lockTimeoutMs` | `number` | `3000` | Maximum time to acquire an advisory lock |
| `maxTransactionAmount` | `number` | `100000000000` | Maximum allowed amount per transaction (smallest unit) |
| `hmacSecret` | `string \| null` | `null` | HMAC secret for tamper-proof hash chains and balance checksums |
| `verifyEntryHashOnRead` | `boolean` | `true` | Verify entry hash chain integrity on every read operation |
| `lockRetryCount` | `number` | `0` | Number of retry attempts on lock timeout or serialization failure |
| `lockRetryBaseDelayMs` | `number` | `50` | Base delay in ms between lock retries (exponential backoff with jitter) |
| `lockRetryMaxDelayMs` | `number` | `500` | Maximum delay in ms between lock retries |
| `lockMode` | `"wait" \| "nowait" \| "optimistic"` | `"wait"` | Lock acquisition mode. `"nowait"` fails immediately if locked. `"optimistic"` skips `FOR UPDATE` entirely — relies on `UNIQUE(account_id, account_version)` constraint on `entry` for conflict detection |
| `optimisticRetryCount` | `number` | `3` | Retry attempts on optimistic lock version conflicts (only used when `lockMode: "optimistic"`) |
| `enableBatching` | `boolean` | `false` | Enable transaction batching for extreme throughput. See [Scaling — Transaction Batching](/docs/scaling#transaction-batching-batch-engine) |
| `batchMaxSize` | `number` | `200` | Maximum transactions per batch (only when `enableBatching: true`) |
| `batchFlushIntervalMs` | `number` | `5` | Maximum ms before an incomplete batch is flushed |

<Callout type="warn" title="Configure hmacSecret in production">
  Without `hmacSecret`, hash chains use plain SHA-256 — an attacker with database access could recompute valid hashes. Set `advanced.hmacSecret` to a strong random string for tamper-proof integrity. Summa logs a warning at startup if this is not configured.
</Callout>

### Configuration Validation

`createSumma()` validates your configuration at startup:

- **Currency** must be a valid ISO 4217 code (50+ supported currencies)
- **Schema** must contain only alphanumeric characters and underscores, starting with a letter or underscore
- **System account identifiers** must start with `@`
- **Numeric options** (`transactionTimeoutMs`, `lockTimeoutMs`, etc.) must be positive finite numbers
- **Database adapter** is required

Invalid configuration throws `SummaError` with code `INVALID_ARGUMENT` immediately, not at first use.

### Startup Warnings

Even with valid configuration, Summa logs warnings at startup for common production oversights:

| Condition | Warning |
|-----------|---------|
| `audit-log` plugin not registered | *"For financial-grade deployments, audit logging is strongly recommended."* |
| `reconciliation` plugin not registered | *"For financial-grade deployments, periodic reconciliation is strongly recommended."* |
| `advanced.hmacSecret` not set | *"Without HMAC, hash chains use plain SHA-256 and an attacker with DB access can recompute valid hashes."* |
| `systemAccounts` set but `hot-accounts` plugin not registered | *"hot-accounts plugin is not registered but system accounts are configured. System accounts typically receive high transaction volume — register hotAccounts() for optimistic concurrency."* |

These are warnings only — Summa will still start. But in production, all four should be addressed.

## Logging & Storage

### `logger`

Custom logger implementation. Defaults to `createConsoleLogger()` — a formatted, colored, PII-redacting console logger (not raw `console`). Must implement:

```ts
interface SummaLogger {
  info(message: string, data?: Record<string, unknown>): void;
  warn(message: string, data?: Record<string, unknown>): void;
  error(message: string, data?: Record<string, unknown>): void;
  debug(message: string, data?: Record<string, unknown>): void;
}
```

#### Built-in JSON Logger

Summa ships with a structured JSON logger for production environments:

```ts
import { createJsonLogger } from "@summa-ledger/core/logger";

const summa = createSumma({
  database: adapter,
  logger: createJsonLogger({ level: "info", service: "ledger" }),
});
```

Each log line is emitted as single-line JSON, suitable for log aggregation (ELK, Datadog, CloudWatch):

```json
{"timestamp":"2026-02-21T10:30:00.000Z","level":"info","service":"ledger","message":"Transaction posted","txnId":"uuid"}
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `level` | `"debug" \| "info" \| "warn" \| "error"` | `"info"` | Minimum log level to emit |
| `service` | `string` | `"summa"` | Service name in structured output |
| `redactKeys` | `string[]` | See below | Keys to redact from log data |

#### PII Redaction

Both the console and JSON loggers support automatic PII redaction. Any matching key in log data is replaced with `"[REDACTED]"`.

**Default redacted keys:** `email`, `phone`, `ssn`, `password`, `token`, `secret`

```ts
// Use defaults — redacts email, phone, ssn, password, token, secret
const logger = createJsonLogger({ level: "info" });

// Add custom keys to the default set
const logger = createJsonLogger({
  level: "info",
  redactKeys: ["creditCard", "bankAccount", "taxId"],
});
```

```ts
logger.info("User created", { name: "Alice", email: "alice@example.com" });
// Output: { ..., "data": { "name": "Alice", "email": "[REDACTED]" } }
```

The same `redactKeys` option is available on `createConsoleLogger()`:

```ts
import { createConsoleLogger } from "@summa-ledger/core/logger";

const logger = createConsoleLogger({
  level: "info",
  prefix: "Ledger",       // Prefix before each message (default: "Summa")
  timestamps: true,        // Include ISO timestamps (default: true)
  redactKeys: ["ssn"],
});
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `level` | `"debug" \| "info" \| "warn" \| "error"` | `"info"` | Minimum log level |
| `prefix` | `string` | `"Summa"` | Prefix shown before each log message |
| `timestamps` | `boolean` | `true` | Include ISO timestamps in output |
| `redactKeys` | `string[]` | See above | Keys to redact from log data |

#### Custom Logger (Pino example)

```ts
import pino from "pino";

const pinoLogger = pino({ level: "info" });

const summa = createSumma({
  database: adapter,
  logger: {
    info: (msg, data) => pinoLogger.info(data, msg),
    warn: (msg, data) => pinoLogger.warn(data, msg),
    error: (msg, data) => pinoLogger.error(data, msg),
    debug: (msg, data) => pinoLogger.debug(data, msg),
  },
});
```

### `secondaryStorage`

Optional key-value store for rate limiting, idempotency caching, and distributed state. **Recommended for multi-instance deployments** — without it, rate limiting is per-process only.

#### Using `@summa-ledger/redis-storage` (Recommended)

The `@summa-ledger/redis-storage` package provides a production-ready `SecondaryStorage` implementation:

```bash
pnpm add @summa-ledger/redis-storage ioredis
```

```ts
import Redis from "ioredis";
import { createRedisStorage } from "@summa-ledger/redis-storage";

const redis = new Redis(process.env.REDIS_URL!);
const { storage, disconnect, ping } = createRedisStorage({
  client: redis,
  keyPrefix: "summa:",   // Default — prefix for all keys
});

const summa = createSumma({
  database: adapter,
  secondaryStorage: storage,
});

// Health check
const healthy = await ping(); // true if Redis is reachable

// On shutdown
await disconnect();
```

#### Custom Implementation

You can also implement the `SecondaryStorage` interface directly:

```ts
interface SecondaryStorage {
  get(key: string): Promise<string | null>;
  set(key: string, value: string, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  increment(key: string, amount?: number): Promise<number>;
}
```

Example with the `redis` package:

```ts
import { createClient } from "redis";

const redis = createClient({ url: process.env.REDIS_URL });
await redis.connect();

const summa = createSumma({
  database: adapter,
  secondaryStorage: {
    get: (key) => redis.get(key),
    set: (key, value, ttl) =>
      ttl ? redis.setEx(key, ttl, value) : redis.set(key, value),
    delete: (key) => redis.del(key).then(() => {}),
    increment: (key, amount = 1) => redis.incrBy(key, amount),
  },
});
```

## CLI Configuration File

For CLI commands, export your config from a file:

```ts title="summa.config.ts"
import { defineSummaConfig } from "@summa-ledger/summa/config";

export default defineSummaConfig({
  database: drizzleAdapter(db),
  currency: "USD",
  plugins: [auditLog(), reconciliation()],
});
```

The `defineSummaConfig` helper provides TypeScript autocompletion **and** validates your configuration at define-time — invalid options (bad currency, malformed schema name, etc.) throw immediately rather than at runtime. You can also export a `summa` named export or a `createSumma()` instance directly.

See [CLI Reference](/docs/cli#config-file-discovery) for the full config discovery path.
