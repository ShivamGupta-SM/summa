---
title: Drizzle Adapter
description: Use Summa with Drizzle ORM and PostgreSQL.
icon: Drizzle
---

## Installation

```bash
pnpm add @summa/drizzle-adapter drizzle-orm pg
```

## Setup

```ts
import { drizzleAdapter } from "@summa/drizzle-adapter";
import { createSumma } from "summa";
import { drizzle } from "drizzle-orm/node-postgres";

const db = drizzle(process.env.DATABASE_URL!);

export const summa = createSumma({
  database: drizzleAdapter(db),
  currency: "USD",
});
```

The `drizzleAdapter()` accepts any Drizzle database instance and returns a `SummaAdapter`.

## Schema Generation

Generate Drizzle-compatible `pgTable()` definitions for all Summa tables:

```bash
npx summa generate --adapter drizzle --out src/db/summa-schema.ts
```

This outputs `pgTable(...)` definitions you can import alongside your own Drizzle schema. If you have plugins configured in your `summa.config.ts`, the generated schema will include their tables too.

```ts title="src/db/summa-schema.ts (generated)"
import { pgTable, uuid, text, bigint, boolean, timestamp, jsonb, index, uniqueIndex } from "drizzle-orm/pg-core";

export const accountBalance = pgTable("account_balance", {
  id: uuid("id").primaryKey(),
  holderId: text("holder_id").notNull(),
  holderType: text("holder_type").notNull(),
  currency: text("currency").notNull(),
  balance: bigint("balance", { mode: "number" }).notNull(),
  // ... more columns
}, (table) => ({
  holderIdIdx: index("account_balance_holder_id_idx").on(table.holderId),
}));

// ... all other tables
```

## Migrations

### Option 1: Direct Push (Recommended for Getting Started)

```bash
npx summa migrate push
```

This reads your config, compares against the database, and applies changes directly via `information_schema` introspection.

### Option 2: Drizzle Kit Migrations

```bash
# 1. Generate Summa schema
npx summa generate --adapter drizzle --out src/db/summa-schema.ts

# 2. Generate migration files
npx drizzle-kit generate

# 3. Apply migrations
npx drizzle-kit push
```

This gives you version-controlled migration files for production deployments.

## Connection Pooling

For production, always use connection pooling. Summa provides `RECOMMENDED_POOL_CONFIG` with production-ready defaults and `createPooledAdapter()` for pool monitoring and graceful shutdown.

### Recommended Setup

```ts
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";
import {
  createPooledAdapter,
  RECOMMENDED_POOL_CONFIG,
} from "@summa/drizzle-adapter";

const pool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_URL,
  // Override defaults as needed:
  // max: 30,
});

const db = drizzle(pool);
const { adapter, close, stats } = createPooledAdapter({ pool, drizzle: db });

export const summa = createSumma({
  database: adapter,
  currency: "USD",
});

// Monitor pool health
setInterval(() => console.log(stats()), 60_000);

// On shutdown
await summa.workers.stop();
await close();
```

### Recommended Pool Defaults

`RECOMMENDED_POOL_CONFIG` includes these production-ready values:

| Setting | Value | Purpose |
|---------|-------|---------|
| `max` | `20` | Max connections. Divide by instance count for multi-instance. |
| `min` | `5` | Keep 5 idle connections warm. |
| `idleTimeoutMillis` | `30000` | Close idle connections after 30s. |
| `connectionTimeoutMillis` | `10000` | Fail fast if no connection in 10s. |
| `maxLifetimeMillis` | `1800000` | Recycle connections after 30min (avoids stale connections behind LBs). |
| `statement_timeout` | `30000` | Prevent runaway queries (30s). |

### Pool Sizing Guidelines

| Workload | `max` connections | Notes |
|----------|:-:|-------|
| Light (< 100 txn/min) | 5–10 | Default for small services |
| Medium (100–1000 txn/min) | 10–20 | Most production workloads |
| Heavy (1000+ txn/min) | 20–50 | Enable hot accounts plugin |

<Callout type="info" title="Multi-instance deployments">
  Divide `max` by the number of instances. For example, with 4 instances and a PostgreSQL `max_connections` of 100, set `max: 20` per instance (leaving room for admin connections).
</Callout>

### Manual Setup

You can also configure the pool manually without `createPooledAdapter`:

```ts
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";
import { drizzleAdapter } from "@summa/drizzle-adapter";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

const db = drizzle(pool);

export const summa = createSumma({
  database: drizzleAdapter(db),
  currency: "USD",
});
```

## Read Replicas

For read-heavy workloads, use `createReadReplicaAdapter()` to route reads to replica(s) and writes to the primary:

```ts
import { createReadReplicaAdapter } from "@summa/core/db";
import { drizzleAdapter } from "@summa/drizzle-adapter";

const primary = drizzleAdapter(drizzle(primaryPool));
const replica = drizzleAdapter(drizzle(replicaPool));

const adapter = createReadReplicaAdapter({
  primary,
  replicas: [replica],
  strategy: "round-robin",   // or "random" (default)
});

export const summa = createSumma({ database: adapter });
```

### How It Works

| Operation | Routed to |
|-----------|-----------|
| `findOne` (without `forUpdate`) | Replica |
| `findMany` | Replica |
| `count` | Replica |
| `raw` (SELECT queries) | Replica |
| `findOne` (with `forUpdate`) | Primary |
| `create`, `update`, `delete` | Primary |
| `rawMutate` | Primary |
| `transaction` (all ops inside) | Primary |
| `advisoryLock` | Primary |

<Callout type="warn" title="Replication lag">
  PostgreSQL streaming replication has a small delay (typically < 100ms). Reads immediately after writes may return stale data if routed to a replica. Operations inside a transaction always use the primary for read-your-writes consistency.
</Callout>

## How It Works

Under the hood, the Drizzle adapter uses **raw SQL** via Drizzle's `sql` template — not Drizzle's type-safe query builder. This is intentional:

- Summa needs full control over `WHERE` clause generation across 20+ dynamic tables
- Financial operations require `FOR UPDATE` row-level locking
- All mutations use `RETURNING *` for atomic read-after-write

### Adapter Capabilities

| Capability | Supported |
|------------|-----------|
| Advisory locks (`pg_advisory_xact_lock`) | Yes |
| `FOR UPDATE` row locking | Yes |
| `RETURNING *` clause | Yes |
| Dialect | PostgreSQL |

### Automatic Case Conversion

- **Database** uses `snake_case` (PostgreSQL convention)
- **Summa API** uses `camelCase` (JavaScript convention)
- The adapter converts automatically — you never deal with snake_case in your code

## Transactions

All Summa operations execute inside a PostgreSQL transaction automatically. The adapter uses Drizzle's built-in transaction support:

```ts
// This is a single atomic operation — debit + credit + event log
await summa.transactions.transfer({
  sourceHolderId: "alice",
  destinationHolderId: "bob",
  amount: 100_00,
  reference: "payment-001",
});
```

## Full Example

```ts
import { createSumma } from "summa";
import {
  createPooledAdapter,
  RECOMMENDED_POOL_CONFIG,
} from "@summa/drizzle-adapter";
import { createReadReplicaAdapter } from "@summa/core/db";
import { createRedisStorage } from "@summa/redis-storage";
import { auditLog, reconciliation, velocityLimits } from "summa/plugins";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import Redis from "ioredis";

// Connection pools
const primaryPool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_URL,
});
const replicaPool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_REPLICA_URL,
});

// Drizzle instances
const primaryDb = drizzle(primaryPool);
const replicaDb = drizzle(replicaPool);

// Pooled adapters with monitoring
const primary = createPooledAdapter({ pool: primaryPool, drizzle: primaryDb });
const replica = createPooledAdapter({ pool: replicaPool, drizzle: replicaDb });

// Read replica routing
const adapter = createReadReplicaAdapter({
  primary: primary.adapter,
  replicas: [replica.adapter],
});

// Redis for rate limiting & caching
const redis = new Redis(process.env.REDIS_URL!);
const { storage, disconnect } = createRedisStorage({ client: redis });

export const summa = createSumma({
  database: adapter,
  currency: "USD",
  secondaryStorage: storage,
  plugins: [auditLog(), reconciliation(), velocityLimits()],
});

// Start workers
await summa.workers.start();

// Graceful shutdown
async function shutdown() {
  await summa.workers.stop();
  await disconnect();
  await primary.close();
  await replica.close();
}

process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
```
