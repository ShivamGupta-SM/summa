---
title: Kysely Adapter
description: Use Summa with Kysely query builder and PostgreSQL.
icon: Kysely
---

## Installation

```bash
pnpm add @summa-ledger/kysely-adapter kysely pg
```

## Setup

```ts
import { kyselyAdapter } from "@summa-ledger/kysely-adapter";
import { createSumma } from "@summa-ledger/summa";
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";

const db = new Kysely({
  dialect: new PostgresDialect({
    pool: new Pool({ connectionString: process.env.DATABASE_URL }),
  }),
});

export const summa = createSumma({
  database: kyselyAdapter(db),
  currency: "USD",
});
```

The `kyselyAdapter()` accepts a `Kysely<any>` instance and returns a `SummaAdapter`.

## Schema Generation

Generate TypeScript interfaces for Kysely:

```bash
npx summa generate --adapter kysely --out src/db/summa-types.ts
```

This outputs typed interfaces and a `Database` type you can merge with your own Kysely database type. If you have plugins configured in your `summa.config.ts`, the generated types include their tables too.

```ts title="src/db/summa-types.ts (generated)"
export interface AccountBalanceTable {
  id: string;
  holder_id: string;
  holder_type: string;
  currency: string;
  balance: number;
  // ... more columns
}

export interface TransactionRecordTable {
  id: string;
  source_holder_id: string;
  destination_holder_id: string;
  amount: number;
  // ... more columns
}

// ... all other table interfaces

// Keys are schema-qualified when using a non-public schema (default: "summa")
export interface Database {
  "summa.account_balance": AccountBalanceTable;
  "summa.transaction_record": TransactionRecordTable;
  // ... all tables
}
```

### Merging with Your Own Types

```ts
import type { Database as SummaDB } from "./summa-types";

interface UsersTable {
  id: string;
  email: string;
  name: string;
}

interface Database extends SummaDB {
  users: UsersTable;
}

const db = new Kysely<Database>({
  dialect: new PostgresDialect({
    pool: new Pool({ connectionString: process.env.DATABASE_URL }),
  }),
});
```

## Migrations

### Option 1: Direct Push (Recommended for Getting Started)

```bash
npx summa migrate push
```

Reads your config, compares against the database via `information_schema`, and applies changes directly.

### Option 2: Kysely Migrations

Write Kysely migration files using the generated types as reference:

```ts title="migrations/001_add_summa_tables.ts"
import { Kysely, sql } from "kysely";

export async function up(db: Kysely<any>): Promise<void> {
  // Use `summa migrate push` instead — it handles
  // all table creation and index management automatically
}
```

For most projects, `summa migrate push` is the simplest approach since Summa manages its own schema.

## Connection Pooling

For production, use connection pooling with `RECOMMENDED_POOL_CONFIG` and `createPooledAdapter()` for pool monitoring and graceful shutdown.

### Recommended Setup

```ts
import { Pool } from "pg";
import { Kysely, PostgresDialect } from "kysely";
import {
  createPooledAdapter,
  RECOMMENDED_POOL_CONFIG,
} from "@summa-ledger/kysely-adapter";

const pool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_URL,
  // Override defaults as needed:
  // max: 30,
});

const db = new Kysely({
  dialect: new PostgresDialect({ pool }),
});

const { adapter, close, stats } = createPooledAdapter({ pool, kysely: db });

export const summa = createSumma({
  database: adapter,
  currency: "USD",
});

// Monitor pool health
setInterval(() => console.log(stats()), 60_000);

// On shutdown
await summa.workers.stop();
await close();
```

### Recommended Pool Defaults

`RECOMMENDED_POOL_CONFIG` includes these production-ready values:

| Setting | Value | Purpose |
|---------|-------|---------|
| `max` | `20` | Max connections. Divide by instance count for multi-instance. |
| `min` | `5` | Keep 5 idle connections warm. |
| `idleTimeoutMillis` | `30000` | Close idle connections after 30s. |
| `connectionTimeoutMillis` | `10000` | Fail fast if no connection in 10s. |
| `maxLifetimeMillis` | `1800000` | Recycle connections after 30min (avoids stale connections behind LBs). |
| `statement_timeout` | `30000` | Prevent runaway queries (30s). |

### Pool Sizing Guidelines

| Workload | `max` connections | Notes |
|----------|:-:|-------|
| Light (< 100 txn/min) | 5–10 | Default for small services |
| Medium (100–1000 txn/min) | 10–20 | Most production workloads |
| Heavy (1000+ txn/min) | 20–50 | Enable hot accounts plugin |

<Callout type="info" title="Multi-instance deployments">
  Divide `max` by the number of instances. For example, with 4 instances and a PostgreSQL `max_connections` of 100, set `max: 20` per instance (leaving room for admin connections).
</Callout>

### Manual Setup

You can also configure the pool manually without `createPooledAdapter`:

```ts
import { Pool } from "pg";
import { Kysely, PostgresDialect } from "kysely";
import { kyselyAdapter } from "@summa-ledger/kysely-adapter";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

const db = new Kysely({
  dialect: new PostgresDialect({ pool }),
});

export const summa = createSumma({
  database: kyselyAdapter(db),
  currency: "USD",
});
```

## How It Works

The Kysely adapter uses **raw SQL** via Kysely's `sql` template — not Kysely's type-safe query builder. This is intentional:

- Summa needs full control over `WHERE` clause generation across 20+ dynamic tables
- Financial operations require `FOR UPDATE` row-level locking
- All mutations use `RETURNING *` for atomic read-after-write

The adapter converts `$1, $2` style placeholders to Kysely's `sql` template literals via an internal `buildKyselySql()` utility.

### Adapter Capabilities

| Capability | Supported |
|------------|-----------|
| Advisory locks (`pg_advisory_xact_lock`) | Yes |
| `FOR UPDATE` row locking | Yes |
| `RETURNING *` clause | Yes |
| Dialect | PostgreSQL |

### Automatic Case Conversion

- **Database** uses `snake_case` (PostgreSQL convention)
- **Summa API** uses `camelCase` (JavaScript convention)
- The adapter converts automatically — you never deal with snake_case in your code

## Transactions

The adapter wraps all operations in Kysely transactions. All Summa operations within a single call execute inside a PostgreSQL transaction:

```ts
// This is a single atomic operation — debit + credit + event log
await summa.transactions.transfer({
  sourceHolderId: "alice",
  destinationHolderId: "bob",
  amount: 100_00,
  reference: "payment-001",
});
```

## Why Kysely?

Kysely is a great choice when you want:

- **Full type safety** with your database queries (outside of Summa operations)
- **No code generation** step — types are inferred from your schema definitions
- **Minimal abstraction** — Kysely is a query builder, not a full ORM
- **Direct SQL control** when needed, with parameterized queries

## Full Example

```ts
import { createSumma } from "@summa-ledger/summa";
import {
  createPooledAdapter,
  RECOMMENDED_POOL_CONFIG,
} from "@summa-ledger/kysely-adapter";
import { createReadReplicaAdapter } from "@summa-ledger/core/db";
import { auditLog, reconciliation, velocityLimits } from "@summa-ledger/summa/plugins";
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";

// Connection pool with production defaults
const pool = new Pool({
  ...RECOMMENDED_POOL_CONFIG,
  connectionString: process.env.DATABASE_URL,
});

const db = new Kysely({
  dialect: new PostgresDialect({ pool }),
});

// Pooled adapter with monitoring
const { adapter, close, stats } = createPooledAdapter({ pool, kysely: db });

export const summa = createSumma({
  database: adapter,
  currency: "USD",
  plugins: [auditLog(), reconciliation(), velocityLimits()],
});

// Run migrations
// npx summa migrate push

// Start background workers
await summa.workers.start();

// Graceful shutdown
async function shutdown() {
  await summa.workers.stop();
  await close();
}

process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
```
