---
title: Client SDK
description: Type-safe HTTP client for consuming the Summa API from other services.
icon: CodeBracket
---

## Overview

The `@summa/client` package provides a **type-safe HTTP client** for consuming the Summa ledger API from other services. It mirrors the entire API surface with full TypeScript types, request/response interceptors, and configurable timeouts.

Use the client SDK when Summa runs as a **standalone service** and your application communicates with it over HTTP.

| Source | Direction | Destination |
|--------|-----------|-------------|
| **Your App** (`@summa/client`) | HTTP (JSON) | **Summa API** (Hono / Express) |

## Installation

```bash
pnpm add @summa/client @summa/core
```

## Quick Start

```ts
import { createSummaClient } from "@summa/client";

const client = createSummaClient({
  baseURL: "http://localhost:3000/api/ledger",
});

// Create an account
const account = await client.accounts.create({
  holderId: "user_123",
  holderType: "individual",
  currency: "USD",
});

// Transfer funds
const txn = await client.transactions.transfer({
  sourceHolderId: "user_123",
  destinationHolderId: "merchant_1",
  amount: 50_00,
  reference: "order-001",
});

// Check balance
const balance = await client.accounts.getBalance("user_123");
```

## Configuration

<TypeTable
  type={{
    baseURL: { type: "string", description: "Base URL of the Summa API.", required: true },
    headers: { type: "Record<string, string>", description: "Static headers included in every request.", default: "{}" },
    fetch: { type: "typeof globalThis.fetch", description: "Custom fetch implementation.", default: "globalThis.fetch" },
    onRequest: { type: "RequestInterceptor | RequestInterceptor[]", description: "Request interceptor(s)." },
    onResponse: { type: "ResponseInterceptor | ResponseInterceptor[]", description: "Response interceptor(s)." },
    timeout: { type: "number", description: "Request timeout in milliseconds.", default: "30000" },
  }}
/>

## Authentication

The client SDK does not enforce any authentication scheme — add your auth headers via `headers` or interceptors:

<Tabs items={["Static API key", "Dynamic token"]}>
<Tab value="Static API key">
```ts
const client = createSummaClient({
  baseURL: "http://ledger:3000/api/ledger",
  headers: {
    "Authorization": `Bearer ${process.env.LEDGER_API_KEY}`,
  },
});
```
</Tab>
<Tab value="Dynamic token">
```ts
const client = createSummaClient({
  baseURL: "http://ledger:3000/api/ledger",
  onRequest: (url, init) => {
    const token = getServiceToken(); // your token provider
    return {
      ...init,
      headers: { ...init.headers, Authorization: `Bearer ${token}` },
    };
  },
});
```
</Tab>
</Tabs>

## Available Methods

<Tabs items={["Accounts", "Transactions", "Holds", "Events", "Limits"]}>
<Tab value="Accounts">
```ts
client.accounts.create(params)       // POST /accounts
client.accounts.get(holderId)        // GET /accounts/:holderId
client.accounts.getBalance(holderId) // GET /accounts/:holderId/balance
client.accounts.freeze(params)       // POST /accounts/:holderId/freeze
client.accounts.unfreeze(params)     // POST /accounts/:holderId/unfreeze
client.accounts.close(params)        // POST /accounts/:holderId/close
client.accounts.list(params?)        // GET /accounts
```
</Tab>
<Tab value="Transactions">
```ts
client.transactions.credit(params)        // POST /transactions/credit
client.transactions.debit(params)         // POST /transactions/debit
client.transactions.transfer(params)      // POST /transactions/transfer
client.transactions.multiTransfer(params) // POST /transactions/multi-transfer
client.transactions.refund(params)        // POST /transactions/refund
client.transactions.get(id)               // GET /transactions/:id
client.transactions.list(params)          // GET /transactions
```
</Tab>
<Tab value="Holds">
```ts
client.holds.create(params)     // POST /holds
client.holds.commit(params)     // POST /holds/:holdId/commit
client.holds.void(params)       // POST /holds/:holdId/void
client.holds.get(id)            // GET /holds/:id
client.holds.listActive(params) // GET /holds/active
client.holds.listAll(params)    // GET /holds
```
</Tab>
<Tab value="Events">
```ts
client.events.getForAggregate(type, id)       // GET /events/:type/:id
client.events.getByCorrelation(correlationId) // GET /events/correlation/:id
client.events.verifyChain(type, id)           // POST /events/verify
```
</Tab>
<Tab value="Limits">
```ts
client.limits.set(params)      // POST /limits
client.limits.get(holderId)    // GET /limits/:holderId
client.limits.remove(params)   // DELETE /limits/:holderId
client.limits.getUsage(params) // GET /limits/:holderId/usage
```
</Tab>
</Tabs>

## Error Handling

<Callout type="info" title="Typed errors">
  The client throws `SummaClientError` for all API errors, with `code`, `status`, and `message` fields.
</Callout>

```ts
import { SummaClientError } from "@summa/client";

try {
  await client.transactions.transfer({ ... });
} catch (error) {
  if (error instanceof SummaClientError) {
    console.log(error.code);    // "INSUFFICIENT_BALANCE"
    console.log(error.status);  // 400
    console.log(error.message); // "Insufficient balance: ..."
  }
}
```

## Interceptors

### Request Interceptor

Modify outgoing requests before they are sent:

```ts
type RequestInterceptor = (
  url: string,
  init: RequestInit,
) => RequestInit | Promise<RequestInit>;
```

```ts
const client = createSummaClient({
  baseURL: "http://ledger:3000/api/ledger",
  onRequest: (url, init) => {
    console.log(`→ ${init.method} ${url}`);
    return init;
  },
});
```

### Response Interceptor

Process responses before they are returned:

```ts
type ResponseInterceptor = (
  response: Response,
  request: { url: string; init: RequestInit },
) => Response | Promise<Response>;
```

```ts
const client = createSummaClient({
  baseURL: "http://ledger:3000/api/ledger",
  onResponse: (response, request) => {
    if (!response.ok) {
      console.error(`← ${response.status} ${request.url}`);
    }
    return response;
  },
});
```

Multiple interceptors can be passed as an array — they execute in order.

## Custom Fetch

Provide a custom `fetch` implementation for environments without a global `fetch`, or for testing:

```ts
import { fetch as undiciFetch } from "undici";

const client = createSummaClient({
  baseURL: "http://ledger:3000/api/ledger",
  fetch: undiciFetch,
});
```

## Proxy Client

For dynamic or plugin endpoints not covered by the typed client, use the **proxy client**. It maps property access chains to URL paths automatically:

```ts
import { createSummaProxyClient } from "@summa/client/proxy";

const client = createSummaProxyClient({
  baseURL: "http://localhost:3000/api/ledger",
});

// GET /admin/accounts
const accounts = await client.admin.accounts.$get();

// POST /admin/accounts/user_123/freeze
await client.admin.accounts("user_123").freeze.$post({ reason: "suspicious" });

// GET /metrics
const metrics = await client.metrics.$get();
```

### Method Hints

| Method | HTTP Verb | Usage |
|--------|-----------|-------|
| `$get(query?)` | GET | Read operations with optional query params |
| `$post(body?)` | POST | Create/mutate operations with JSON body |
| `$put(body?)` | PUT | Update operations |
| `$delete(body?)` | DELETE | Delete operations |

Dynamic path segments are inserted by calling the proxy node as a function:

```ts
client.transactions("txn-uuid").$get()  // GET /transactions/txn-uuid
client.holds("hold-id").commit.$post()   // POST /holds/hold-id/commit
```

## Framework Bindings

The client SDK includes first-class bindings for React, Vue, and Svelte. Each binding provides query and mutation patterns with loading/error state management.

<Tabs items={["React", "Vue", "Svelte"]}>
<Tab value="React">

```bash
pnpm add @summa/client react
```

```tsx
import { SummaProvider, useSumma, useSummaQuery, useSummaMutation } from "@summa/client/react";

// Wrap your app
function App() {
  return (
    <SummaProvider options={{ baseURL: "/api/ledger" }}>
      <Dashboard />
    </SummaProvider>
  );
}

// Query data
function Dashboard() {
  const { data: balance, loading, error, refetch } = useSummaQuery(
    (client) => client.accounts.getBalance("user_123"),
    ["user_123"],
  );

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  return <p>Balance: {balance?.balance}</p>;
}

// Mutations
function TransferButton() {
  const { mutate, loading } = useSummaMutation(
    (client, params: { to: string; amount: number }) =>
      client.transactions.transfer({
        sourceHolderId: "user_123",
        destinationHolderId: params.to,
        amount: params.amount,
        reference: `transfer-${Date.now()}`,
      }),
  );

  return (
    <button onClick={() => mutate({ to: "merchant_1", amount: 50_00 })} disabled={loading}>
      {loading ? "Sending..." : "Transfer $50"}
    </button>
  );
}
```

| Hook | Returns | Description |
|------|---------|-------------|
| `useSumma()` | `SummaClient` | Access the client from context |
| `useSummaQuery(fn, deps?)` | `{ data, error, loading, refetch }` | Auto-fetching query with dependency tracking |
| `useSummaMutation(fn)` | `{ mutate, data, error, loading }` | On-demand mutation with state |

</Tab>
<Tab value="Vue">

```bash
pnpm add @summa/client vue
```

```vue
<script setup>
import { provideSumma, useSummaQuery, useSummaMutation } from "@summa/client/vue";

// In parent component
provideSumma({ baseURL: "/api/ledger" });

// Query
const { data: balance, loading, error, refetch } = useSummaQuery(
  (client) => client.accounts.getBalance("user_123"),
);

// Mutation
const { mutate: transfer, loading: sending } = useSummaMutation(
  (client, params) => client.transactions.transfer(params),
);
</script>
```

| Composable | Returns | Description |
|------------|---------|-------------|
| `provideSumma(options)` | `SummaClient` | Provide client via Vue `provide()` |
| `useSummaClient()` | `SummaClient` | Inject client from parent |
| `useSummaQuery(fn)` | `{ data: Ref, error: Ref, loading: Ref, refetch }` | Auto-fetching reactive query |
| `useSummaMutation(fn)` | `{ mutate, data: Ref, error: Ref, loading: Ref }` | On-demand mutation with refs |

</Tab>
<Tab value="Svelte">

```bash
pnpm add @summa/client svelte
```

```svelte
<script>
import { createSummaStore } from "@summa/client/svelte";

const { client, query, mutation } = createSummaStore({
  baseURL: "/api/ledger",
});

const balance = query((c) => c.accounts.getBalance("user_123"));
const transfer = mutation((c, params) => c.transactions.transfer(params));
</script>

{#if $balance.loading}
  <p>Loading...</p>
{:else if $balance.error}
  <p>Error: {$balance.error.message}</p>
{:else}
  <p>Balance: {$balance.data?.balance}</p>
{/if}

<button
  on:click={() => transfer.trigger({ sourceHolderId: "user_123", destinationHolderId: "merchant_1", amount: 5000, reference: "order-1" })}
  disabled={$transfer.loading}
>
  Transfer
</button>
```

| Function | Returns | Description |
|----------|---------|-------------|
| `createSummaStore(options)` | `{ client, query, mutation }` | Create a store factory |
| `query(fn)` | Readable store `{ data, error, loading }` + `refetch()` | Auto-fetching store |
| `mutation(fn)` | Readable store `{ data, error, loading }` + `trigger(vars)` | On-demand mutation store |

</Tab>
</Tabs>
